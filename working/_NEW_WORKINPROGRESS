include("_NEW_FINAL_LIB");
// _________________________________________________________________________

global assoc_item_uniqueID = []; 
// debug de chaque tour on reclean ça
for(var id in getWeapons()+getChips()) assoc_item_uniqueID[id]=[];
 
global assoc_from_uniqueID = [];
//debut de chaque tour on reclean ça
for(var i=0; i<613; i++) if(_OBSTACLES!=null) assoc_from_uniqueID[i]=[];

global assoc_cost_uniqueID = [];
for(var i=1; i<10;i++) assoc_cost_uniqueID[i] = [];

global assoc_uniqueID_cost = [];
assoc_uniqueID_cost = [];

global uniqueID_bestinitialfrom = [];
uniqueID_bestinitialfrom=[];

global assoc_uniqueID_from = [];
assoc_uniqueID_from = [];

global randUniqueID = [];
randUniqueID = [];
 
global _LEEKS_COEF;
//debut de chaque tour
_LEEKS_COEF = [];
for(var target in getAliveAllies()+getAliveEnemies()){
    var coef;
    if(isAlly(target)){
        if(isSummon(target)) coef = -1;
        else coef = -2;
    }else{
        if(isSummon(target)) coef = 1;
        else coef = 2;
    }
    _LEEKS_COEF[target]=coef;
}
 

// refresh à tous les tours de l'état de tout le monde.
 
/*
EFFECT_ABSOLUTE_SHIELD
EFFECT_ANTIDOTE
EFFECT_BOOST_MAX_LIFE
EFFECT_BUFF_AGILITY
// EFFECT_BUFF_FORCE ?deprecated
EFFECT_BUFF_MP
EFFECT_BUFF_RESISTANCE
EFFECT_BUFF_STRENGTH
EFFECT_BUFF_TP
EFFECT_BUFF_WISDOM
// EFFECT_DAMAGE ?done
EFFECT_DAMAGE_RETURN
EFFECT_DEBUFF
// EFFECT_HEAL ?done
EFFECT_INVERT
EFFECT_KILL
// EFFECT_POISON ?done
EFFECT_RELATIVE_SHIELD
EFFECT_RESURRECT
EFFECT_SHACKLE_MAGIC
EFFECT_SHACKLE_MP
EFFECT_SHACKLE_STRENGTH
EFFECT_SHACKLE_TP
EFFECT_SUMMON
EFFECT_TELEPORT
_______________________________________
EFFECT_TARGET_ALLIES
EFFECT_TARGET_CASTER
EFFECT_TARGET_ENEMIES
EFFECT_TARGET_NON_SUMMONS
EFFECT_TARGET_NOT_CASTER
EFFECT_TARGET_SUMMONS
*/
 
function getVirtualState(@leek, @stackOfResult){
    var state = _LEEKS[leek];
    state["life"]-=stackOfResult[leek]["dmg"];
    state["life"]+=stackOfResult[leek]["heal"];
    if(state["totallife"]>state["life"])state["life"]=state["totallife"];
    state["psnlife"]=state["life"]-0/*TODO psnDmgTurn*/-stackOfResult[leek]["psn"];
    return @state;
}
 
function getScoreOfAction(@action, @stackOfResult, @stackOfDeath){
    var myStr = _LEEKS[_SELF]["str"],
    myMgc = _LEEKS[_SELF]["mgc"],
    myWis = _LEEKS[_SELF]["wsd"],
    item = action["item"],
    lifeMissing = _LEEKS[_SELF]["totallife"]-_LEEKS[_SELF]["life"],
    area = _ITEM_AREA[item],
    isAOE = area==AREA_CIRCLE_1||area==AREA_CIRCLE_2||area==AREA_CIRCLE_3,
    effects = @_ITEM_EFFECTS[item],
    score = 0;
 
    for(var target in action["targets"]){
        if(target==_SELF) continue; // ignore self, je ne suis pas sur la case ici !
        if(stackOfDeath[target]==true) continue; // si la cible est déjà morte, next !
        var virtualTargetState = getVirtualState(target, stackOfResult);
        var dmgRatio = isAOE? getDamagePercentage(getCell(target), action["to"], area) : 100;
       
        var coef = _LEEKS_COEF[target];
       
        var minDmgValue=0, avgDmgValue=0, turnPsn=0, avgPsn=0, healValue=0, lifeSteal=0;
        for(var e in effects){
            if(e[0] == EFFECT_DAMAGE){
                // TODO check if liberate before: dont apply reduc.
                minDmgValue += ( e[1]*(1+(myStr/100))
                    *(1-(virtualTargetState["relShield"]/100))
                    *(dmgRatio/100)) - virtualTargetState["absShield"];
                avgDmgValue += (((e[1]+e[2])/2)*(1+(myStr/100))
                    *(1-(virtualTargetState["relShield"]/100))
                    *(dmgRatio/100)) - virtualTargetState["absShield"];
            }
            else if(e[0] == EFFECT_POISON){
                turnPsn += e[1]*(1+(myMgc/100))*(dmgRatio/100);
                avgPsn += ((e[1]+e[2])/2)*(1+(myMgc/100))*(dmgRatio/100) *(e[3]-1);// 1tour de moins que le max.
                // soit 100%, 67%, 33% sur 3 tours vu les effects de heal/libération.
            }
            else if(e[0] == EFFECT_HEAL){
                healValue = ((e[1]+e[2])/2)*(1+(myWis/100))*(dmgRatio/100);
            }
            else{
    //debugE("unhandled:"+getWeaponName(action["item"])+getChipName(action["item"]));
            }
        }
        //kill?
        // ici maybe check if damage pas < à 0 !
        if(virtualTargetState["life"]<=minDmgValue){
            minDmgValue=virtualTargetState["life"];
            stackOfDeath[target]=true;
            score+=(minDmgValue+500)*coef;         
            //lifesteal
            lifeSteal+=minDmgValue*myWis/10;
            if(lifeSteal>0){
                if(lifeSteal>lifeMissing)lifeSteal=lifeMissing;
                lifeMissing-=lifeSteal;
                score+=lifeSteal;
                stackOfResult[target]["heal"]+=lifeSteal;
            }
            //lifestealend
        }else if(virtualTargetState["psnlife"]-minDmgValue <= turnPsn){
            stackOfDeath[target]=true;
            score+=(turnPsn+250)*coef;
        }else{
            if(stackOfResult[target]==null)stackOfResult[target]=[];
            if(avgDmgValue>0){
                stackOfResult[target]["dmg"]+=minDmgValue; // sauvegarde du min
                score +=avgDmgValue*coef; // score de l'avg
                //lifesteal
                lifeSteal+=avgDmgValue*myWis/10;
                if(lifeSteal>0){
                    if(lifeSteal>lifeMissing)lifeSteal=lifeMissing;
                    lifeMissing-=lifeSteal;
                    score+=lifeSteal;
                    stackOfResult[target]["heal"]+=lifeSteal;
                }
                //lifestealend
            }
            if(avgPsn>0){
                stackOfResult[target]["psn"]+=turnPsn;
                score +=avgPsn*coef;
            }
            if(healValue){
                stackOfResult[target]["heal"]+=healValue;
                score -=healValue*coef;
            }
        }
    }
    return @score;
}
 
function addActionToMAPS(@item, @from, @to, @targets){
	var dist = reachableCells[from];
    if(dist==null)return; // filtering all action I can't reach
    var uniqueID = getUniqueID(targets, item, to);
    // création du tab si inexistant
    if(map_actions[uniqueID]==null){
		map_actions[uniqueID]= ["uniqueID":uniqueID, "to":to, "item":item, "targets":targets];
		push(randUniqueID, uniqueID);
	}
    // ajout dans map item
    push(assoc_item_uniqueID[item], uniqueID);
    // ajout dans map from
    push(assoc_from_uniqueID[from], uniqueID);	
	// ajout dans map cost
	push(assoc_cost_uniqueID[_ITEM_COST[item]], uniqueID);
	
	if(assoc_uniqueID_cost[uniqueID]==null) assoc_uniqueID_cost[uniqueID]=_ITEM_COST[item];
	
	if(assoc_uniqueID_from[uniqueID]==null) assoc_uniqueID_from[uniqueID] = [];
	push(assoc_uniqueID_from[uniqueID], from);
	// replace/add dans la map uniqueid bestFrom
	if(reachableCells[uniqueID_bestinitialfrom[uniqueID]] > dist)
		uniqueID_bestinitialfrom[uniqueID]=from;
		

}
 
// remplis des tableaux avec toutes les actions possibles pour mon leek, ranger avec différentes clés pour trier tout ça...
// c'est encore en construction, je ne me suis pas arrêté définitivement sur le modèle, j'expériemente pas mal là, je commence l'implémentation de l'algo de sac à dos, jvais surement refactor :)
function setMapActions(){
	map_actions = [];//clear
    var self = getLeek(), interest;
    for(var w in getWeapons()){
        var weaponArea = getWeaponArea(w);
        var minrange = getWeaponMinRange(w);
        var maxrange = getWeaponMaxRange(w);
        if(weaponArea == AREA_POINT){ // normal cible unique.
            for(var target in getAliveEnemies()){ // pas d'ally susceptible d'être une cible.
                var toCell = getCell(target);
                var targets = [target];
                for(var from in _getCellsToUseWeapChipOnCell(w, toCell)){
                    addActionToMAPS(w, from, toCell, targets);
                }
            }
        }else if(weaponArea == AREA_LASER_LINE){ // cas d'un lazer
            for(var fromCell = 0; fromCell < 613; fromCell++){
                if(_OBSTACLES[fromCell]==null){
                    for(var toCell in getLazerTargetsCell(fromCell, minrange)){
                        var targets = getLazerTargetsFromCell(fromCell, toCell, minrange, maxrange);
                        if(count(targets)>0){// ici du coup je rend le b_lazer useless
                            interest=0; // du fait de la simplification du test
                            for(var t in targets) interest+=_LEEKS_COEF[t];
                            if(interest>0) addActionToMAPS(w, fromCell, toCell, targets);
                        }
                    }
                }
            }
        }else{// cas des aoe AREA_CIRCLE_X (1, 2, 3)
        // TODO maybe opti en faisant qu'une fois les calcs par area pour weapon & chip
            for(var i = 0; i < 613; i++){
                if(_OBSTACLES[i]==null){
                    var targets = getWeaponTargets(w, i);
                    if(count(targets)>0){
                        interest=0;
                        for(var t in targets)
                            interest+=_LEEKS_COEF[t]*getDamagePercentage(i, getCell(t), weaponArea)/100;
                        if(interest>0) for(var from in _getCellsToUseWeapChipOnCell(w, i)){
                            addActionToMAPS(w, from, i, targets);
                        }
                    }
                }
            }
        }
    }// end for weapons
    for(var c in getChips()){
        if(getCooldown(c)!=0 || isSpecialChip(c)) continue;
        // pour le moment on gère pas les special chip
        var chipArea = getChipArea(c);
        // cannot be lazer_line
        if(chipArea==AREA_POINT){
            var targets = isPositivChip(c) ? getAliveAllies() : getAliveEnemies();
            for(var target in targets){
                if(target==_SELF) continue; // TODO les actions ou je me cible moi mm sont gérer ailleurs.... quand j'aurais réfléchis à ça..
                var toCell = getCell(target);
                for(var from in _getCellsToUseWeapChipOnCell(c, toCell)){
                    addActionToMAPS(c, from, toCell, [target]);
                }
            }
        }else if(chipArea==AREA_LASER_LINE){
            debugE("CHIP LAZERLINE ?!?");
        }else{// cas des aoe AREA_CIRCLE_X (1, 2, 3)
        // TODO maybe opti en faisant qu'une fois les calcs par area pour weapon & chip
            var isPositiv = isPositivChip(c);
            for(var i = 0; i < 613; i++){
                if(_OBSTACLES[i]==null){
                    var targets = getChipTargets(c, i);
                    if(count(targets)>0){
                        interest=0;
                        for(var t in targets){
                            if(isPositiv)interest -= _LEEKS_COEF[t]* getDamagePercentage(i, getCell(t), chipArea)/100;
                            else interest += _LEEKS_COEF[t]* getDamagePercentage(i, getCell(t), chipArea)/100;
                        }
                        if(interest>0) for(var from in _getCellsToUseWeapChipOnCell(c, i)){
                            addActionToMAPS(c, from, i, targets);
                        }
                    }
                }
            }
        }
    }//end for chips
}

global __SETWEAPON=0, __MOVETOWARDCELL=1, __USEITEMONCELL=2;

global _MOVES, _BESTSCORE;
_MOVES = [];
_BESTSCORE = 0; // reinit à chaque recherche de bestmove.
// cette fonction doit trouver le "bestmove"
// j'ai pas encore décidé de tout ce que je vais faire ici, j'aimerais bien un algo génétique mais je suis emmerdé par la nécessité deconnaitre les conséquences du premier coup pour avoir le score réel du deuxième coup
// du coup pour le moment jvais faire un test en choisissant les 2 ou 3 actions meilleurs actions par item/puces comme premier coup, puis recommencer jusqu'à épuisement des ressources, et voir ce que ça donne niveau opé et qualité de résultat..
// y'a aussi le problème des MP, faudrait que j'ai un tableau assoc from:[actions..] mais jsais pas encore comment gérer le téléport... ptete que je le gère pas et que je m'en sers que dans des cas spéciaux genre finish et escape
function getBestMove(){
    var scoreMap = [];
    var stackResultMap = [];
    var stackDeathMap = [];
    startOp();
    // pour chaque action, je calcule le score
    for(var uniqueID:var action in map_actions){
			var result = [], death = [];
			scoreMap[uniqueID] = getScoreOfAction(action, result, death);
			stackResultMap[uniqueID] = result;
			stackDeathMap[uniqueID] = death;
    }
    stopOp("calcul all actions !");
    //debugE(scoreMap);// dans scoreMap j'ai le score du premier move de chaque action possible.
	// assoc_from_uniqueID[cell]:[array uniqueid]
	// assoc_item_uniqueID[iditem]:[array uniqueid]
	// uniqueID_bestinitialfrom
	
	// j'ai maintenant une estimation du cout:
	var bestScoreByItem = [];
	for(var item in getWeapons()+getChips()){
		bestScoreByItem[item]=[];
		bestScoreByItem[item] = arraySort(assoc_item_uniqueID[item], function(a, b){
			if(scoreMap[a]<scoreMap[b]) return 1;
			else if(scoreMap[a]>scoreMap[b]) return -1;
			return 0;
		});
	}
	
	var idx = 0, curPlay = [], curScore = 0;
	var bestScore = null, bestPlay = null;
	while(getOperations()<19*1000*1000){
		for(var item in getWeapons()+getChips()){
		
			if(count(bestScoreByItem[item]) > idx){
				// état initial d'un move
				var TP = getTP(), MP = getMP(), W = getWeapon();
				// première action
				var uniqueID = bestScoreByItem[item][idx];
				var cost = _ITEM_COST[item], switch = false;
				var action = @map_actions[uniqueID];
				var fromCell = uniqueID_bestinitialfrom[uniqueID];
				if(_ITEM_ISWEAP[item] && W!=item){
					cost+=1;
					switch=true;
				}
				TP-=cost;
				MP-=reachableCells[fromCell];
				if(TP<0 || MP<0) break; // j'ai plus de TP/MP, action impossible à play
				else{
					curScore += scoreMap[uniqueID];
					if(switch) push(curPlay, ["action":__SETWEAPON, "param1":item]);
					push(curPlay, ["action":__MOVETOWARDCELL, "param1":fromCell]);
					push(curPlay, ["action":__USEITEMONCELL, "param1":item, "param2":action["to"]]);
					
					addMoarAction(fromCell, TP, MP, item, curPlay, curScore, stackResultMap[uniqueID], stackDeathMap[uniqueID]);
					
					if(bestScore==null || bestScore<curScore){
						bestScore=curScore;
						bestPlay=curPlay;
					}
				}
				
			}
		}
		idx++;
	}
	debugW("BEST SCORE:"+bestScore);
	return @bestPlay;
}

function addMoarAction(@cell, @tp, @mp, @w, @curPlay, @curScore, @stackResultMap, @stackDeathMap){
	var reachable = getReachableCells([cell:0], mp, []);
	
	var map_doableActions = [];
	var assoc_uniqueId_cellfrom = [];
	var closestCell, tmpDist, dist, cost, a, item;
	for(var id in randUniqueID){
		//check tp
		cost = assoc_uniqueID_cost[id];
		a = map_actions[id];
		item = a["item"];
		if(_ITEM_ISWEAP[item] && item!=w) cost+=1;
		if(tp<=cost) continue;
		//check mp
		closestCell=null;
		dist=10000;
		for(var cellFrom in assoc_uniqueID_from[id]){
			tmpDist = reachable[cellFrom];
			if(tmpDist!=null && dist>tmpDist){
				closestCell=cellFrom;
				dist=tmpDist;
			}
		}
		if(closestCell!=null){
			//DOABLE §§
			assoc_uniqueId_cellfrom[id]=closestCell;
			map_doableActions[id]=@a;
		}
		
	}
	
	var max = count(map_doableActions);
	if(max=0){
		// find safest cell
		var finalCell = getBestSafeCell(cell, mp, "safe");
		push(curPlay, ["action":__MOVETOWARDCELL, "param1":finalCell]);
		curScore-= maps_danger[finalCell];
		if(maps_danger[finalCell]>getLife()) curScore -= 1000;
		return;
	}else{
		// rand action
		var action = map_doableActions[randInt(0, max)];
		item = action["item"];
		var uniqueID = action["uniqueID"];
		cost = assoc_uniqueID_cost[uniqueID];
		var fromCell = assoc_uniqueId_cellfrom[uniqueID];
		var switch = false;
		if(_ITEM_ISWEAP[item] && item!=w){
			switch=true;
			cost+=1;
		}
		tp-=cost;
		mp-=reachable[fromCell];
		var tmpScore = getScoreOfAction(action, stackResultMap, stackDeathMap);
		curScore += tmpScore;
		 
		if(switch) push(curPlay, ["action":__SETWEAPON, "param1":item]);
		push(curPlay, ["action":__MOVETOWARDCELL, "param1":fromCell]);
		push(curPlay, ["action":__USEITEMONCELL, "param1":item, "param2":action["to"]]);
					
		addMoarAction(fromCell, tp, mp, item, curPlay, curScore, stackResultMap, stackDeathMap);
	}	
}

function playBestMove(@bestMove){
	for(var action in bestMove){
		var a = action["action"];
		var p1 = action["param1"];
		var p2 = action["param2"];
		if(a==__SETWEAPON) setWeapon(p1);
		else if(a==__MOVETOWARDCELL) moveTowardCell(p1);
		else if(a==__USEITEMONCELL){
			if(_ITEM_ISWEAP[p1]) useWeaponOnCell(p2);
			else useChipOnCell(p1, p2);
		}
	}
}