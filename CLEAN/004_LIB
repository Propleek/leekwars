include('auto');
///////////////////////////////////////////
// Ma lib
///////////////////////////////////////////

function sayCupidon(){
	var stupidSay = [
		"Je hais Lucky Luke ! Je hais Lucky Luke !"
		,"Tagada, tagada, voilà les daltons !"
		,"FREE HUGS !!"
		,"MAGIE NOIRE ! MAGIE NOIRE ! Tais-toi, tais-toi, tais-toi la patte de poulet Satan hérétique !!"
		,"Ah, non, pour moi les femmes, j'aime pas ça.. C'est de la saloperie !"
		,"Simplet ! Le démon a vidé ton cerveau, y'a plus rien dedans. Tu périras par la main de Dieu, tu comprends ça ?"
		,"Oh Regarde, Simplet, Regarde ! Il y a un morceau de charcuterie qui arrive ! Regarde le, Regarde ! ... AU BÛCHER !"
		,"Qu'est-ce que j'apprends de manière inopinée ? La rumeur colporte que vous ne vous êtes jamais confessé !"
		,"La confession ! Sans confession, point de salut ! Sans salut, point... point ne sert de... à rien qui ne sait partir."
	];
	if(!isSummon(getNearestEnemy())) push(stupidSay, getName(getNearestEnemy()) + " est un hérétique, je VEUX BRÛLER CETTE PERSONNE !");
	
	if(getName()=="JoeDalton") push(stupidSay, "Contrainte : Corps à corps only, pas de bulbes.");
	if(getName()=="WilliamDalton") push(stupidSay, "Contrainte : Pas d'armes, pas de bulbes.");
	if(getName()=="JackDalton") push(stupidSay, "Contrainte : Pas de puces.");
	
	say(stupidSay[randInt(0, count(stupidSay))]);
}

function getComboSet(@entity){
	var eType = getEntityType(entity), TP = getTP(), combos = [];
	if(eType==ENTITY_LEEK_){
		// liste des combos à tester
		var comboz = jsonDecode(getFullRegister(getTP()));
		// choix du set de combo en fonction de mon état
		if(getWeapon()==null) combos = @comboz["EMPTY"];
		else combos = @comboz[string(getWeapon())];
	}else if(eType==ENTITY_PUNY_BULB){
		//TODO
	}else if(eType==ENTITY_ROCKY_BULB){
		if(TP>=12) push(combos, [CHIP_ROCKFALL, CHIP_ROCK, CHIP_PEBBLE]);
		if(TP>=10) push(combos, [CHIP_ROCKFALL, CHIP_ROCK]);
		if(TP>=8) push(combos, [CHIP_ROCKFALL, CHIP_HELMET]);
		if(TP>=7) push(combos, [CHIP_ROCKFALL, CHIP_PEBBLE]);
		if(TP>=8) push(combos, [CHIP_ROCK, CHIP_HELMET]);
		if(TP>=5) push(combos, [CHIP_ROCKFALL]);
		if(TP>=7) push(combos, [CHIP_ROCK, CHIP_PEBBLE]);
		if(TP>=5) push(combos, [CHIP_ROCK]);
		if(TP>=5) push(combos, [CHIP_HELMET, CHIP_PEBBLE]);
		if(TP>=3) push(combos, [CHIP_HELMET]);
		if(TP>=2) push(combos, [CHIP_PEBBLE]);
	}else if(eType==ENTITY_ICED_BULB){
		if(TP>=13) push(combos, [CHIP_ICEBERG, CHIP_STALACTITE]);
		if(TP>=14) push(combos, [CHIP_REFLEXES, CHIP_ICEBERG]);
		if(TP>=13) push(combos, [CHIP_REFLEXES, CHIP_STALACTITE]);
		if(TP>=11) push(combos, [CHIP_ICEBERG, CHIP_ICE]);
		if(TP>=10) push(combos, [CHIP_STALACTITE, CHIP_ICE]);
		if(TP>=7) push(combos, [CHIP_ICEBERG]);
		if(TP>=6) push(combos, [CHIP_STALACTITE]);
		if(TP>=11) push(combos, [CHIP_REFLEXES, CHIP_ICE]);
		if(TP>=12) push(combos, [CHIP_ICE, CHIP_ICE, CHIP_ICE]);
		if(TP>=8) push(combos, [CHIP_ICE, CHIP_ICE]);
		if(TP>=7) push(combos, [CHIP_REFLEXES]);
		if(TP>=4) push(combos, [CHIP_ICE]);
	}else if(eType==ENTITY_HEALER_BULB){
		if(TP>=17) push(combos, [CHIP_CURE, CHIP_DRIP, CHIP_BANDAGE, CHIP_VACCINE]);
		if(TP>=13) push(combos, [CHIP_DRIP, CHIP_BANDAGE, CHIP_VACCINE]);
		if(TP>=12) push(combos, [CHIP_CURE, CHIP_BANDAGE, CHIP_VACCINE]);
		if(TP>=11) push(combos, [CHIP_CURE, CHIP_DRIP, CHIP_BANDAGE]);
		if(TP>=11) push(combos, [CHIP_DRIP, CHIP_VACCINE]);
		if(TP>=10) push(combos, [CHIP_CURE, CHIP_VACCINE]);
		if(TP>=9) push(combos, [CHIP_DRIP, CHIP_CURE]);
		if(TP>=8) push(combos, [CHIP_BANDAGE, CHIP_VACCINE]);
		if(TP>=7) push(combos, [CHIP_DRIP, CHIP_BANDAGE]);
		if(TP>=6) push(combos, [CHIP_CURE, CHIP_BANDAGE]);
		if(TP>=6) push(combos, [CHIP_VACCINE]);
		if(TP>=5) push(combos, [CHIP_DRIP]);
		if(TP>=4) push(combos, [CHIP_CURE]);
		if(TP>=2) push(combos, [CHIP_BANDAGE]);
	}else if(eType==ENTITY_METALLIC_BULB){
		if(TP>=12) push(combos, [CHIP_ARMOR, CHIP_SEVEN_LEAGUE_BOOTS]);
		if(TP>=10) push(combos, [CHIP_ARMOR, CHIP_SHIELD]);
		if(TP>=10) push(combos, [CHIP_SEVEN_LEAGUE_BOOTS, CHIP_SHIELD]);
		if(TP>=9) push(combos, [CHIP_SEVEN_LEAGUE_BOOTS, CHIP_WALL]);
		if(TP>=9) push(combos, [CHIP_ARMOR, CHIP_WALL]);
		if(TP>=7) push(combos, [CHIP_SHIELD, CHIP_WALL]);
		if(TP>=6) push(combos, [CHIP_ARMOR]);
		if(TP>=6) push(combos, [CHIP_SEVEN_LEAGUE_BOOTS]);
		if(TP>=4) push(combos, [CHIP_SHIELD]);
		if(TP>=3) push(combos, [CHIP_WALL]);
	}else if(eType==ENTITY_FIRE_BULB){
		if(TP>=14) push(combos, [CHIP_METEORITE, CHIP_DEVIL_STRIKE]);
		if(TP>=12) push(combos, [CHIP_METEORITE, CHIP_FLAME]);
		if(TP>=11) push(combos, [CHIP_METEORITE, CHIP_SPARK]);
		if(TP>=10) push(combos, [CHIP_FLAME, CHIP_DEVIL_STRIKE]);
		if(TP>=12) push(combos, [CHIP_FLAME, CHIP_FLAME, CHIP_FLAME]);
		if(TP>=8) push(combos, [CHIP_METEORITE]);
		if(TP>=9) push(combos, [CHIP_SPARK, CHIP_DEVIL_STRIKE]);
		if(TP>=8) push(combos, [CHIP_FLAME, CHIP_FLAME]);
		if(TP>=6) push(combos, [CHIP_DEVIL_STRIKE]);
		if(TP>=12) push(combos, [CHIP_SPARK, CHIP_SPARK, CHIP_SPARK, CHIP_SPARK]);
		if(TP>=9) push(combos, [CHIP_SPARK, CHIP_SPARK, CHIP_SPARK]);
		if(TP>=6) push(combos, [CHIP_SPARK, CHIP_SPARK]);
	}else if(eType==ENTITY_LIGHTNING_BULB){
		if(TP>=16) push(combos, [CHIP_LIGHTNING, CHIP_LIGHTNING, CHIP_LIGHTNING, CHIP_LIGHTNING]);
		if(TP>=14) push(combos, [CHIP_LIGHTNING, CHIP_LIGHTNING, CHIP_LIGHTNING, CHIP_SHOCK]);
		if(TP>=12) push(combos, [CHIP_LIGHTNING, CHIP_LIGHTNING, CHIP_LIGHTNING]);
		if(TP>=13) push(combos, [CHIP_DOPING, CHIP_LIGHTNING, CHIP_LIGHTNING]);
		if(TP>=10) push(combos, [CHIP_LIGHTNING, CHIP_LIGHTNING, CHIP_SHOCK]);
		if(TP>=11) push(combos, [CHIP_DOPING, CHIP_LIGHTNING]);
		if(TP>=11) push(combos, [CHIP_DOPING, CHIP_FLASH]);
		if(TP>=8) push(combos, [CHIP_LIGHTNING, CHIP_LIGHTNING]);
		if(TP>=9)  push(combos, [CHIP_DOPING, CHIP_SHOCK]);
		if(TP>=7)  push(combos, [CHIP_DOPING]);
		if(TP>=12) push(combos, [CHIP_LIGHTNING, CHIP_LIGHTNING, CHIP_FLASH]);
		if(TP>=10) push(combos, [CHIP_SHOCK, CHIP_SHOCK, CHIP_SHOCK, CHIP_SHOCK, CHIP_SHOCK]);
		if(TP>=8) push(combos, [CHIP_FLASH, CHIP_SHOCK, CHIP_SHOCK]);
		if(TP>=8) push(combos, [CHIP_SHOCK, CHIP_SHOCK, CHIP_SHOCK, CHIP_SHOCK]);
		if(TP>=4) push(combos, [CHIP_LIGHTNING]);
		if(TP>=4) push(combos, [CHIP_FLASH]);
		if(TP>=6) push(combos, [CHIP_SHOCK, CHIP_SHOCK, CHIP_SHOCK]);
		if(TP>=4) push(combos, [CHIP_SHOCK, CHIP_SHOCK]);
		if(TP>=2) push(combos, [CHIP_SHOCK]);
	}
	return @combos;
}

/**
 * Retourne la liste de tous les poireaux/bulbes qui vont jouer entre l'entité donné et le lanceur de la fonction
 *
 * @param int leek ID de l'entité ciblée
 *
 * @return array Tableau des ID des entités qui vont jouer entre le caster et la cible (caster et cible exclus)
 */
function getListOfLeekWhoPlayBefore(@leek){
	var leekWhoPlayBefore = [];
	var casterTurnOrder = getEntityTurnOrder();
	var limitTurnOrder = getEntityTurnOrder(leek);
	for(var entity in getAliveAllies() + getAliveEnemies()){
		var entityTurnOrder = getEntityTurnOrder(entity);
		//Cas le plus simple, on récupère les entités entre le caster et la cible
		if(casterTurnOrder < limitTurnOrder){
			//si l'entité est entre le caster et la cible
			if(casterTurnOrder < entityTurnOrder && entityTurnOrder < limitTurnOrder){
				push(leekWhoPlayBefore, entity);
			}
		}
		//Plus complexe, la cible joue avant le caster
		else{
			//On récupère déjà toutes les entités jouant après le caster, sans limite
			if(casterTurnOrder < entityTurnOrder){
				push(leekWhoPlayBefore, entity);
			}
			//Puis toutes celles jouant avant la cible
			if(entityTurnOrder < limitTurnOrder){
				push(leekWhoPlayBefore, entity);
			}
		}
	}
	return @leekWhoPlayBefore;
}

function getListOfLeekToIgnoreForLazer(@leek){
	var leekToIgnore = getAliveAllies();
	var casterTurnOrder = getEntityTurnOrder();
	var limitTurnOrder = getEntityTurnOrder(leek);
	for(var entity in getAliveEnemies()){
		if(isSummon(entity)) push(leekToIgnore, entity);
		else{
			var entityTurnOrder = getEntityTurnOrder(entity);
			//Cas le plus simple, on récupère les entités entre le caster et la cible
			if(casterTurnOrder < limitTurnOrder){
				//si l'entité est entre le caster et la cible
				if(casterTurnOrder < entityTurnOrder && entityTurnOrder < limitTurnOrder){
					push(leekToIgnore, entity);
				}
			}
			//Plus complexe, la cible joue avant le caster
			else{
				//On récupère déjà toutes les entités jouant après le caster, sans limite
				if(casterTurnOrder < entityTurnOrder){
					push(leekToIgnore, entity);
				}
				//Puis toutes celles jouant avant la cible
				if(entityTurnOrder < limitTurnOrder){
					push(leekToIgnore, entity);
				}
			}
		}
	}
	return @leekToIgnore;
}

/**
 * Retourne la liste de tous les poireaux/bulbes adverses qui vont jouer après l'entité donné et avant le lanceur de la fonction
 *
 * @param int leek ID de l'entité ciblée
 *
 * @return array Tableau des ID des entités adverses qui vont jouer après le caster et avant la cible (caster et cible exclus)
 */
function getListOfEnemyLeekWhoPlayAfter(@leek){
	var leekWhoPlayBefore = [];
	var casterTurnOrder = getEntityTurnOrder();
	var limitTurnOrder = getEntityTurnOrder(leek);
	for(var entity in getAliveEnemies()){
		var entityTurnOrder = getEntityTurnOrder(entity);
		//Cas le plus simple, on récupère les entités entre le caster et la cible
		if(casterTurnOrder < limitTurnOrder){
			//si l'entité est entre le caster et la cible
			if(casterTurnOrder < entityTurnOrder && entityTurnOrder < limitTurnOrder){
				push(leekWhoPlayBefore, entity);
			}
		}
		//Plus complexe, la cible joue avant le caster
		else{
			//On récupère déjà toutes les entités jouant après le caster, sans limite
			if(casterTurnOrder < entityTurnOrder){
				push(leekWhoPlayBefore, entity);
			}
			//Puis toutes celles jouant avant la cible
			if(entityTurnOrder < limitTurnOrder){
				push(leekWhoPlayBefore, entity);
			}
		}
	}
	var leekWhoWontPlayBefore = getAliveEnemies();
	for(var en in leekWhoPlayBefore) removeElement(leekWhoWontPlayBefore, en);
	return @leekWhoWontPlayBefore;
}


function getDamagePercentage(@cell1, @cell2, @area) {     
	if (cell1 == cell2) return 100;
	var dist = getCellDistance(cell1, cell2),
	areaDist = area-2;// tricks pour win 5op ! mais la func bug si area_circle change de value de constante
	if(dist > areaDist ) return 0;
	return @(100 - ((50 / areaDist) * dist));
}

// renvoie si la puce a un effet positif ou négatif sur la cible
function isPositivChip(@c){
	return @_CHIP_ISPOSITIV[c];
}

// renvoie si la puce fait partie des puces non-standard
// soit summon, resurrection (cible les morts), teleport & inversion (déplacement)
function isSpecialChip(@c){
	return @(_CHIP_ISSPECIAL[c]!=null);
}

// return an array of cell that can be targeted with lazer from c using minrange
function getLazerTargetsCell(@c, @minrange){
	var x = getCellX(c), y = getCellY(c), result = [];
	var cell = getCellFromXY(x+minrange, y);
	if(cell!=null && _OBSTACLES[cell]==null && lineOfSight(c, cell, _EMPTYARRAY)) push(result, cell);
	cell = getCellFromXY(x-minrange, y);
	if(cell!=null && _OBSTACLES[cell]==null && lineOfSight(c, cell, _EMPTYARRAY)) push(result, cell);
	cell = getCellFromXY(x, y+minrange);
	if(cell!=null && _OBSTACLES[cell]==null && lineOfSight(c, cell, _EMPTYARRAY)) push(result, cell);
	cell = getCellFromXY(x, y-minrange);
	if(cell!=null && _OBSTACLES[cell]==null && lineOfSight(c, cell, _EMPTYARRAY)) push(result, cell);
	return @result;
}

// return an array of cell from witch you can shoot on c with lazer having min/max range
function getLazerFromCellsToTargetCell(@c, @minrange, @maxrange){
	var x = getCellX(c), y = getCellY(c), result = [];
	var cell = getCellFromXY(x+minrange, y), inc = 1;
	if(cell!=null && _OBSTACLES[cell]==null && _LEEKS_CELL[cell]==null && lineOfSight(c, cell, _EMPTYARRAY)){
		while(cell!=null && _OBSTACLES[cell]==null && _LEEKS_CELL[cell]==null && getCellDistance(c, cell)<=maxrange){
			push(result, cell);
			cell = getCellFromXY(x+minrange+inc++, y);
		}
	}
	cell = getCellFromXY(x-minrange, y); inc = 1;
	if(cell!=null && _OBSTACLES[cell]==null && _LEEKS_CELL[cell]==null && lineOfSight(c, cell, _EMPTYARRAY)){
		while(cell!=null && _OBSTACLES[cell]==null && _LEEKS_CELL[cell]==null && getCellDistance(c, cell)<=maxrange){
			push(result, cell);
			cell = getCellFromXY(x-minrange-inc++, y);
		}
	}
	cell = getCellFromXY(x, y+minrange); inc = 1;
	if(cell!=null && _OBSTACLES[cell]==null && _LEEKS_CELL[cell]==null && lineOfSight(c, cell, _EMPTYARRAY)){
		while(cell!=null && _OBSTACLES[cell]==null && _LEEKS_CELL[cell]==null && getCellDistance(c, cell)<=maxrange){
			push(result, cell);
			cell = getCellFromXY(x, y+minrange+inc++);
		}
	}
	cell = getCellFromXY(x, y-minrange); inc = 1;
	if(cell!=null && _OBSTACLES[cell]==null && _LEEKS_CELL[cell]==null && lineOfSight(c, cell, _EMPTYARRAY)){
		while(cell!=null && _OBSTACLES[cell]==null && _LEEKS_CELL[cell]==null && getCellDistance(c, cell)<=maxrange){
			push(result, cell);
			cell = getCellFromXY(x, y-minrange-inc++);
		}
	}
	return @result;
}

// return lazerTargets array
function getLazerTargetsFromCell(@from, @to, @minrange, @maxrange){
	var xFrom = getCellX(from), yFrom = getCellY(from),
		xTo = getCellX(to), yTo = getCellY(to), result = [],
		inc = 0, maxInc = maxrange-getCellDistance(from, to), tmpCell, tmpContent;
	
	if(xFrom==xTo){
		if(yFrom<yTo){
			// y++
			while(true){
				tmpCell = getCellFromXY(xTo, yTo+inc);
				if(tmpCell == null || _OBSTACLES[tmpCell]!=null || inc > maxInc) break;
				tmpContent = getCellContent(tmpCell);
				if(tmpContent == CELL_PLAYER) push(result, getLeekOnCell(tmpCell));
				inc++;
			}
		}else{
			// y--
			while(true){
				tmpCell = getCellFromXY(xTo, yTo-inc);
				if(tmpCell == null || _OBSTACLES[tmpCell]!=null || inc > maxInc) break;
				tmpContent = getCellContent(tmpCell);
				if(tmpContent == CELL_PLAYER) push(result, getLeekOnCell(tmpCell));
				inc++;
			}
		}
	}else if(yFrom==yTo){
		if(xFrom<xTo){
			// x++
			while(true){
				tmpCell = getCellFromXY(xTo+inc, yTo);
				if(tmpCell == null || _OBSTACLES[tmpCell]!=null || inc > maxInc) break;
				tmpContent = getCellContent(tmpCell);
				if(tmpContent == CELL_PLAYER) push(result, getLeekOnCell(tmpCell));
				inc++;
			}
		}else{
			// x--
			while(true){
				tmpCell = getCellFromXY(xTo-inc, yTo);
				if(tmpCell == null || _OBSTACLES[tmpCell]!=null || inc > maxInc) break;
				tmpContent = getCellContent(tmpCell);
				if(tmpContent == CELL_PLAYER) push(result, getLeekOnCell(tmpCell));
				inc++;
			}
		}
	}
	
	return @result;
}

// renvoie un array de cell depuis lesquel on peut tirer sur cell
// ne fonctionne que pour le leek qui l'utilise, j'utilise leekToIgnore = [getLeek()]
// pour les lignes de vue et _LEEKS pour les cases non accessibles (ou il y a tout le monde sauf le leek)
// donc pas pour les bulbes cette fonction !
function _getCellsToUseWeapChipOnCell(@weapChip, @cell){
	var leekToIgnore = [getLeek()],result = [],
	x = getCellX(cell), y = getCellY(cell),
	minrange = _ITEM_MINRANGE[weapChip],
	maxrange = _ITEM_MAXRANGE[weapChip],
	inline = _ITEM_INLINE[weapChip],
	needlos = _ITEM_NEEDLOS[weapChip];
	if(inline){
		for(var x1 = x-maxrange; x1 <= x+maxrange; x1++){
			var dist =((x-x1)<0?-(x-x1):x-x1);
			if(dist < minrange) continue;
			var fromCell = getCellFromXY(x1, y);
			if(fromCell!=null 
			&& _OBSTACLES[fromCell]==null 
			&& _LEEKS_CELL[fromCell]==null
			&& (!needlos || lineOfSight(fromCell, cell, leekToIgnore))){
				push(result, fromCell);
			}
		}
		for(var y1 = y-maxrange; y1 <= y+maxrange; y1++){
			var dist =((y-y1)<0?-(y-y1):y-y1);
			if(dist < minrange) continue;
			var fromCell = getCellFromXY(x, y1);
			if(fromCell!=null 
			&& _OBSTACLES[fromCell]==null 
			&& _LEEKS_CELL[fromCell]==null
			&& (!needlos || lineOfSight(fromCell, cell, leekToIgnore))){
				push(result, fromCell);
			}
		}
	}else{
		for(var x1 = x-maxrange; x1 <= x+maxrange; x1++){
			for(var y1 = y-maxrange; y1 <= y+maxrange; y1++){
				var dist =((x-x1)<0?-(x-x1):x-x1)+(y-y1<0?-(y-y1):y-y1);//trick pour abs(x-x1)+abs(y-y1)..
				if(dist > maxrange || dist < minrange) continue;
				var fromCell = getCellFromXY(x1, y1);
				if(fromCell!=null 
				&& _OBSTACLES[fromCell]==null 
				&& _LEEKS_CELL[fromCell]==null
				&& (!needlos || lineOfSight(fromCell, cell, leekToIgnore))){
					push(result, fromCell);
				}
			}
		}
	}
	return @result;
}

function bulb_getCellsToUseChipOnCell(@weapChip, @cell){
	var leekToIgnore = [getLeek()],result = [],
	x = getCellX(cell), y = getCellY(cell),
	minrange = _ITEM_MINRANGE[weapChip],
	maxrange = _ITEM_MAXRANGE[weapChip],
	inline = _ITEM_INLINE[weapChip],
	needlos = _ITEM_NEEDLOS[weapChip];
	for(var x1 = x-maxrange; x1 <= x+maxrange; x1++){
		for(var y1 = y-maxrange; y1 <= y+maxrange; y1++){
			var fromCell = getCellFromXY(x1, y1);
			if(fromCell!=null 
			&& _OBSTACLES[fromCell]==null 
			&& !isLeek(fromCell)){
				var dist = getCellDistance(fromCell,cell);
				if(dist >= minrange && dist <= maxrange
				&& (!inline || isOnSameLine(fromCell,cell))
				&& (!needlos || lineOfSight(fromCell, cell, leekToIgnore))){
					push(result, fromCell);
				}
			}
		}
	}
	return @result;
}

/* this func is deprecated, _SELF_FULLMAP_PATH_DIST ne fait plus la mm chose...
function _getCellToUseWeapChipOnCell(@weapChip, @cell){
	var leekToIgnore = [getLeek()],result, mpDist = 100,
	x = getCellX(cell), y = getCellY(cell), isWeap = isWeapon(weapChip),
	minrange = isWeap ? getWeaponMinRange(weapChip) : getChipMinRange(weapChip),
	maxrange = isWeap ? getWeaponMaxRange(weapChip) : getChipMaxRange(weapChip),
	inline = isWeap ? isInlineWeapon(weapChip) : isInlineChip(weapChip),
	needlos = isWeap ? weaponNeedLos(weapChip) : chipNeedLos(weapChip);
	for(var x1 = x-maxrange; x1 <= x+maxrange; x1++){
		for(var y1 = y-maxrange; y1 <= y+maxrange; y1++){
			var fromCell = getCellFromXY(x1, y1);
			if(fromCell!=null 
			&& _OBSTACLES[fromCell]==null 
			&& _LEEKS_CELL[fromCell]==null){
				var dist = getCellDistance(fromCell,cell);
				if(dist >= minrange && dist <= maxrange
				&& (!needlos || lineOfSight(fromCell, cell, leekToIgnore))
				&& (!inline || isOnSameLine(fromCell,cell))){
					if(_SELF_FULLMAP_PATH_DIST[fromCell]!=null && _SELF_FULLMAP_PATH_DIST[fromCell]<mpDist){
						mpDist=_SELF_FULLMAP_PATH_DIST[fromCell];
						result=fromCell;
					}
				}
			}
		}
	}
	return @result;
}*/

function _getTargetableCells(@weapChip, @cell){
	if(_CACHE_ITEM_FROMCELL_TARGETCELLS[weapChip][cell]==null){
		var result = [], x = getCellX(cell), y = getCellY(cell),
		minrange = _ITEM_MINRANGE[weapChip],
		maxrange = _ITEM_MAXRANGE[weapChip],
		inline = _ITEM_INLINE[weapChip],
		needlos = _ITEM_NEEDLOS[weapChip];
		if(inline){
			for(var x1 = x-maxrange; x1 <= x+maxrange; x1++){
				var dist =((x-x1)<0?-(x-x1):x-x1);
				if(dist < minrange) continue;
				var fromCell = getCellFromXY(x1, y);
				if(fromCell!=null 
				&& _OBSTACLES[fromCell]==null 
				&& _LEEKS_CELL[fromCell]==null
				&& (!needlos || lineOfSight(fromCell, cell, _EMPTYARRAY))){
					push(result, fromCell);
				}
			}
			for(var y1 = y-maxrange; y1 <= y+maxrange; y1++){
				var dist =((y-y1)<0?-(y-y1):y-y1);
				if(dist < minrange) continue;
				var fromCell = getCellFromXY(x, y1);
				if(fromCell!=null 
				&& _OBSTACLES[fromCell]==null 
				&& _LEEKS_CELL[fromCell]==null
				&& (!needlos || lineOfSight(fromCell, cell, _EMPTYARRAY))){
					push(result, fromCell);
				}
			}
		}else{
			for(var x1 = x-maxrange; x1 <= x+maxrange; x1++){
				for(var y1 = y-maxrange; y1 <= y+maxrange; y1++){
					var dist =((x-x1)<0?-(x-x1):x-x1)+(y-y1<0?-(y-y1):y-y1);//trick pour abs(x-x1)+abs(y-y1)..
					if(dist > maxrange || dist < minrange) continue;
					var fromCell = getCellFromXY(x1, y1);
					if(fromCell!=null 
					&& _OBSTACLES[fromCell]==null 
					&& _LEEKS_CELL[fromCell]==null
					&& (!needlos || lineOfSight(fromCell, cell, _EMPTYARRAY))){
						push(result, fromCell);
					}
				}
			}
		}
		_CACHE_ITEM_FROMCELL_TARGETCELLS[weapChip][cell]= @result;
	}
	return @_CACHE_ITEM_FROMCELL_TARGETCELLS[weapChip][cell];
}

function prepareSetMapActions(){
	atkCellsArea1 = [];
	atkCellsArea2 = [];
	atkCellsArea3 = [];
	defCellsArea1 = [];
	defCellsArea2 = [];
	defCellsArea3 = []; // raz
	for(var e in _ALIVE_ENEMIES){
		var cell = getCell(e);
		atkCellsArea1[cell]=cell;
		atkCellsArea2[cell]=cell;
		atkCellsArea3[cell]=cell;
		for(var c in _areaCells1[cell]){
			atkCellsArea1[c]=c;
			atkCellsArea2[c]=c;
			atkCellsArea3[c]=c;
		}
		for(var c in _areaCells2[cell]){
			atkCellsArea2[c]=c;
			atkCellsArea3[c]=c;
		}
		for(var c in _areaCells3[cell]){
			atkCellsArea3[c]=c;
		}
	}
	for(var e in _ALIVE_ALLIES){
		var cell = getCell(e);
		defCellsArea1[cell]=cell;
		defCellsArea2[cell]=cell;
		defCellsArea3[cell]=cell;
		for(var c in _areaCells1[cell]){
			defCellsArea1[c]=c;
			defCellsArea2[c]=c;
			defCellsArea3[c]=c;
		}
		for(var c in _areaCells2[cell]){
			defCellsArea2[c]=c;
			defCellsArea3[c]=c;
		}
		for(var c in _areaCells3[cell]){
			defCellsArea3[c]=c;
		}
	}
}