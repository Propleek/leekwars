include('auto');
///////////////////////////////////////////
// Ma lib
///////////////////////////////////////////

function sayCupidon(){
	var stupidSay = [
		"Si taga est sur le chat, dites lui de coder ma map de danger plutôt que de glander.."
		,"hmm... avec téléport ça serait plus simple non ?"
		,"Je suis perdu là, c'est où la bagarre ?"
		,"Vous avez vu ? non ? moi non plus."
		,"Demain dès l'aube, à l'heure où blanchie la campagne, je partirai..."
		,"Ne courrez pas, nous venons en paix ! pew pew pew !"
		,"Et si l'homme est un chien c'est qu'il est plus fidèle, plus fidèle à des chattes qui se feront la belle !"
		,"Quand dieu créa la mer rouge, il sala mal l'écume."
		,"<3"
		,"Négatif, je suis une mite en pull-over"
		,"Vous allez vous aimer les uns les autres bordel de merde ?!"
	];
	say(stupidSay[randInt(0, count(stupidSay))]);
}

function getComboSet(@entity){
	var eType = getEntityType(entity), TP = getTP(), combos = [];
	if(eType==ENTITY_ROCKY_BULB){
		if(TP>=12) push(combos, [CHIP_ROCKFALL, CHIP_ROCK, CHIP_PEBBLE]);
		if(TP>=10) push(combos, [CHIP_ROCKFALL, CHIP_ROCK]);
		if(TP>=8) push(combos, [CHIP_ROCKFALL, CHIP_HELMET]);
		if(TP>=7) push(combos, [CHIP_ROCKFALL, CHIP_PEBBLE]);
		if(TP>=8) push(combos, [CHIP_ROCK, CHIP_HELMET]);
		if(TP>=5) push(combos, [CHIP_ROCKFALL]);
		if(TP>=7) push(combos, [CHIP_ROCK, CHIP_PEBBLE]);
		if(TP>=5) push(combos, [CHIP_ROCK]);
		if(TP>=5) push(combos, [CHIP_HELMET, CHIP_PEBBLE]);
		if(TP>=3) push(combos, [CHIP_HELMET]);
		if(TP>=2) push(combos, [CHIP_PEBBLE]);
	}else if(eType==ENTITY_ICED_BULB){
		if(TP>=13) push(combos, [CHIP_ICEBERG, CHIP_STALACTITE]);
		if(TP>=14) push(combos, [CHIP_REFLEXES, CHIP_ICEBERG]);
		if(TP>=13) push(combos, [CHIP_REFLEXES, CHIP_STALACTITE]);
		if(TP>=11) push(combos, [CHIP_ICEBERG, CHIP_ICE]);
		if(TP>=10) push(combos, [CHIP_STALACTITE, CHIP_ICE]);
		if(TP>=7) push(combos, [CHIP_ICEBERG]);
		if(TP>=6) push(combos, [CHIP_STALACTITE]);
		if(TP>=11) push(combos, [CHIP_REFLEXES, CHIP_ICE]);
		if(TP>=12) push(combos, [CHIP_ICE, CHIP_ICE, CHIP_ICE]);
		if(TP>=8) push(combos, [CHIP_ICE, CHIP_ICE]);
		if(TP>=7) push(combos, [CHIP_REFLEXES]);
		if(TP>=4) push(combos, [CHIP_ICE]);
	}else if(eType==ENTITY_HEALER_BULB){
		if(TP>=17) push(combos, [CHIP_CURE, CHIP_DRIP, CHIP_BANDAGE, CHIP_VACCINE]);
		if(TP>=13) push(combos, [CHIP_DRIP, CHIP_BANDAGE, CHIP_VACCINE]);
		if(TP>=12) push(combos, [CHIP_CURE, CHIP_BANDAGE, CHIP_VACCINE]);
		if(TP>=11) push(combos, [CHIP_CURE, CHIP_DRIP, CHIP_BANDAGE]);
		if(TP>=11) push(combos, [CHIP_DRIP, CHIP_VACCINE]);
		if(TP>=10) push(combos, [CHIP_CURE, CHIP_VACCINE]);
		if(TP>=9) push(combos, [CHIP_DRIP, CHIP_CURE]);
		if(TP>=8) push(combos, [CHIP_BANDAGE, CHIP_VACCINE]);
		if(TP>=7) push(combos, [CHIP_DRIP, CHIP_BANDAGE]);
		if(TP>=6) push(combos, [CHIP_CURE, CHIP_BANDAGE]);
		if(TP>=6) push(combos, [CHIP_VACCINE]);
		if(TP>=5) push(combos, [CHIP_DRIP]);
		if(TP>=4) push(combos, [CHIP_CURE]);
		if(TP>=2) push(combos, [CHIP_BANDAGE]);
	}else if(eType==ENTITY_METALLIC_BULB){
		if(TP>=12) push(combos, [CHIP_ARMOR, CHIP_SEVEN_LEAGUE_BOOTS]);
		if(TP>=10) push(combos, [CHIP_ARMOR, CHIP_SHIELD]);
		if(TP>=10) push(combos, [CHIP_SEVEN_LEAGUE_BOOTS, CHIP_SHIELD]);
		if(TP>=9) push(combos, [CHIP_SEVEN_LEAGUE_BOOTS, CHIP_WALL]);
		if(TP>=9) push(combos, [CHIP_ARMOR, CHIP_WALL]);
		if(TP>=7) push(combos, [CHIP_SHIELD, CHIP_WALL]);
		if(TP>=6) push(combos, [CHIP_ARMOR]);
		if(TP>=6) push(combos, [CHIP_SEVEN_LEAGUE_BOOTS]);
		if(TP>=4) push(combos, [CHIP_SHIELD]);
		if(TP>=3) push(combos, [CHIP_WALL]);
	}else if(eType==ENTITY_FIRE_BULB){
		if(TP>=14) push(combos, [CHIP_METEORITE, CHIP_DEVIL_STRIKE]);
		if(TP>=12) push(combos, [CHIP_METEORITE, CHIP_FLAME]);
		if(TP>=11) push(combos, [CHIP_METEORITE, CHIP_SPARK]);
		if(TP>=10) push(combos, [CHIP_FLAME, CHIP_DEVIL_STRIKE]);
		if(TP>=12) push(combos, [CHIP_FLAME, CHIP_FLAME, CHIP_FLAME]);
		if(TP>=8) push(combos, [CHIP_METEORITE]);
		if(TP>=9) push(combos, [CHIP_SPARK, CHIP_DEVIL_STRIKE]);
		if(TP>=8) push(combos, [CHIP_FLAME, CHIP_FLAME]);
		if(TP>=6) push(combos, [CHIP_DEVIL_STRIKE]);
		if(TP>=12) push(combos, [CHIP_SPARK, CHIP_SPARK, CHIP_SPARK, CHIP_SPARK]);
		if(TP>=9) push(combos, [CHIP_SPARK, CHIP_SPARK, CHIP_SPARK]);
		if(TP>=6) push(combos, [CHIP_SPARK, CHIP_SPARK]);
	}else if(eType==ENTITY_LIGHTNING_BULB){
		if(TP>=16) push(combos, [CHIP_LIGHTNING, CHIP_LIGHTNING, CHIP_LIGHTNING, CHIP_LIGHTNING]);
		if(TP>=14) push(combos, [CHIP_LIGHTNING, CHIP_LIGHTNING, CHIP_LIGHTNING, CHIP_SHOCK]);
		if(TP>=12) push(combos, [CHIP_LIGHTNING, CHIP_LIGHTNING, CHIP_LIGHTNING]);
		if(TP>=13) push(combos, [CHIP_DOPING, CHIP_LIGHTNING, CHIP_LIGHTNING]);
		if(TP>=10) push(combos, [CHIP_LIGHTNING, CHIP_LIGHTNING, CHIP_SHOCK]);
		if(TP>=11) push(combos, [CHIP_DOPING, CHIP_LIGHTNING]);
		if(TP>=11) push(combos, [CHIP_DOPING, CHIP_FLASH]);
		if(TP>=8) push(combos, [CHIP_LIGHTNING, CHIP_LIGHTNING]);
		if(TP>=9)  push(combos, [CHIP_DOPING, CHIP_SHOCK]);
		if(TP>=7)  push(combos, [CHIP_DOPING]);
		if(TP>=12) push(combos, [CHIP_LIGHTNING, CHIP_LIGHTNING, CHIP_FLASH]);
		if(TP>=10) push(combos, [CHIP_SHOCK, CHIP_SHOCK, CHIP_SHOCK, CHIP_SHOCK, CHIP_SHOCK]);
		if(TP>=8) push(combos, [CHIP_FLASH, CHIP_FLASH]);
		if(TP>=8) push(combos, [CHIP_SHOCK, CHIP_SHOCK, CHIP_SHOCK, CHIP_SHOCK]);
		if(TP>=4) push(combos, [CHIP_LIGHTNING]);
		if(TP>=4) push(combos, [CHIP_FLASH]);
		if(TP>=6) push(combos, [CHIP_SHOCK, CHIP_SHOCK, CHIP_SHOCK]);
		if(TP>=4) push(combos, [CHIP_SHOCK, CHIP_SHOCK]);
		if(TP>=2) push(combos, [CHIP_SHOCK]);
	}
	return @combos;
}

/**
 * Retourne la liste de tous les poireaux/bulbes qui vont jouer entre l'entité donné et le lanceur de la fonction
 *
 * @param int leek ID de l'entité ciblée
 *
 * @return array Tableau des ID des entités qui vont jouer entre le caster et la cible (caster et cible exclus)
 */
function getListOfLeekWhoPlayBefore(@leek){
	var leekWhoPlayBefore = [];
	if(getLevel()<46) return @leekWhoPlayBefore;
	var casterTurnOrder = getEntityTurnOrder();
	var limitTurnOrder = getEntityTurnOrder(leek);
	for(var entity in getAliveAllies() + getAliveEnemies()){
		var entityTurnOrder = getEntityTurnOrder(entity);
		//Cas le plus simple, on récupère les entités entre le caster et la cible
		if(casterTurnOrder < limitTurnOrder){
			//si l'entité est entre le caster et la cible
			if(casterTurnOrder < entityTurnOrder && entityTurnOrder < limitTurnOrder){
				push(leekWhoPlayBefore, entity);
			}
		}
		//Plus complexe, la cible joue avant le caster
		else{
			//On récupère déjà toutes les entités jouant après le caster, sans limite
			if(casterTurnOrder < entityTurnOrder){
				push(leekWhoPlayBefore, entity);
			}
			//Puis toutes celles jouant avant la cible
			if(entityTurnOrder < limitTurnOrder){
				push(leekWhoPlayBefore, entity);
			}
		}
	}
	return @leekWhoPlayBefore;
}

function getListOfLeekToIgnoreForLazer(@leek){
	var leekToIgnore = getAliveAllies();
	if(getLevel()<46) return @leekToIgnore;
	var casterTurnOrder = getEntityTurnOrder();
	var limitTurnOrder = getEntityTurnOrder(leek);
	for(var entity in getAliveEnemies()){
		if(isSummon(entity)) push(leekToIgnore, entity);
		else{
			var entityTurnOrder = getEntityTurnOrder(entity);
			//Cas le plus simple, on récupère les entités entre le caster et la cible
			if(casterTurnOrder < limitTurnOrder){
				//si l'entité est entre le caster et la cible
				if(casterTurnOrder < entityTurnOrder && entityTurnOrder < limitTurnOrder){
					push(leekToIgnore, entity);
				}
			}
			//Plus complexe, la cible joue avant le caster
			else{
				//On récupère déjà toutes les entités jouant après le caster, sans limite
				if(casterTurnOrder < entityTurnOrder){
					push(leekToIgnore, entity);
				}
				//Puis toutes celles jouant avant la cible
				if(entityTurnOrder < limitTurnOrder){
					push(leekToIgnore, entity);
				}
			}
		}
	}
	return @leekToIgnore;
}

/**
 * Retourne la liste de tous les poireaux/bulbes adverses qui vont jouer après l'entité donné et avant le lanceur de la fonction
 *
 * @param int leek ID de l'entité ciblée
 *
 * @return array Tableau des ID des entités adverses qui vont jouer après le caster et avant la cible (caster et cible exclus)
 */
function getListOfEnemyLeekWhoPlayAfter(@leek){
	var leekWhoPlayBefore = [];
	if(getLevel()<46) return @leekWhoPlayBefore;
	var casterTurnOrder = getEntityTurnOrder();
	var limitTurnOrder = getEntityTurnOrder(leek);
	for(var entity in getAliveEnemies()){
		var entityTurnOrder = getEntityTurnOrder(entity);
		//Cas le plus simple, on récupère les entités entre le caster et la cible
		if(casterTurnOrder < limitTurnOrder){
			//si l'entité est entre le caster et la cible
			if(casterTurnOrder < entityTurnOrder && entityTurnOrder < limitTurnOrder){
				push(leekWhoPlayBefore, entity);
			}
		}
		//Plus complexe, la cible joue avant le caster
		else{
			//On récupère déjà toutes les entités jouant après le caster, sans limite
			if(casterTurnOrder < entityTurnOrder){
				push(leekWhoPlayBefore, entity);
			}
			//Puis toutes celles jouant avant la cible
			if(entityTurnOrder < limitTurnOrder){
				push(leekWhoPlayBefore, entity);
			}
		}
	}
	var leekWhoWontPlayBefore = getAliveEnemies();
	for(var en in leekWhoPlayBefore) removeElement(leekWhoWontPlayBefore, en);
	return @leekWhoWontPlayBefore;
}


function getDamagePercentage(@cell1, @cell2, @area) {     
	if (cell1 == cell2) return 100;
	var dist = getCellDistance(cell1, cell2),
	areaDist = area-2;// tricks pour win 5op ! mais la func bug si area_circle change de value de constante
	if(dist > areaDist ) return 0;
	return @(100 - ((50 / areaDist) * dist));
}

function getAllEnemyBulb(){
	var bulbz = [];
	for(var en in getAliveEnemies()) if(isSummon(en)) push(bulbz, en);
	return @bulbz;
}

// return an array of cells according to AREA_CIRCLE_XX
// cost 3, 4 or 5 op more than @_areaCellsX[cell]
// depending of number of if()
// 1 op per if + 1 for calling func + 1 from I dunno ?
// so use directly the array for final version of optimised func
function getCellArea(@c){
	return @_areaCells1[c];
}

// renvoie si la puce a un effet positif ou négatif sur la cible
function isPositivChip(@c){
	return @_CHIP_ISPOSITIV[c];
}

// renvoie si la puce fait partie des puces non-standard
// soit summon, resurrection (cible les morts), teleport & inversion (déplacement)
function isSpecialChip(@c){
	return @(_CHIP_ISSPECIAL[c]!=null);
}

// return an array of cell that can be targeted with lazer from c using minrange
function getLazerTargetsCell(@c, @minrange){
	var x = getCellX(c), y = getCellY(c), result = [];
	var cell = getCellFromXY(x+minrange, y);
	if(cell!=null && _OBSTACLES[cell]==null && lineOfSight(c, cell, _EMPTYARRAY)) push(result, cell);
	cell = getCellFromXY(x-minrange, y);
	if(cell!=null && _OBSTACLES[cell]==null && lineOfSight(c, cell, _EMPTYARRAY)) push(result, cell);
	cell = getCellFromXY(x, y+minrange);
	if(cell!=null && _OBSTACLES[cell]==null && lineOfSight(c, cell, _EMPTYARRAY)) push(result, cell);
	cell = getCellFromXY(x, y-minrange);
	if(cell!=null && _OBSTACLES[cell]==null && lineOfSight(c, cell, _EMPTYARRAY)) push(result, cell);
	return @result;
}

// return an array of cell from witch you can shoot on c with lazer having min/max range
function getLazerFromCellsToTargetCell(@c, @minrange, @maxrange){
	var x = getCellX(c), y = getCellY(c), result = [];
	var cell = getCellFromXY(x+minrange, y), inc = 1;
	if(cell!=null && _OBSTACLES[cell]==null && _LEEKS_CELL[cell]==null && lineOfSight(c, cell, _EMPTYARRAY)){
		while(cell!=null && _OBSTACLES[cell]==null && _LEEKS_CELL[cell]==null && getCellDistance(c, cell)<=maxrange){
			push(result, cell);
			cell = getCellFromXY(x+minrange+inc++, y);
		}
	}
	cell = getCellFromXY(x-minrange, y); inc = 1;
	if(cell!=null && _OBSTACLES[cell]==null && _LEEKS_CELL[cell]==null && lineOfSight(c, cell, _EMPTYARRAY)){
		while(cell!=null && _OBSTACLES[cell]==null && _LEEKS_CELL[cell]==null && getCellDistance(c, cell)<=maxrange){
			push(result, cell);
			cell = getCellFromXY(x-minrange-inc++, y);
		}
	}
	cell = getCellFromXY(x, y+minrange); inc = 1;
	if(cell!=null && _OBSTACLES[cell]==null && _LEEKS_CELL[cell]==null && lineOfSight(c, cell, _EMPTYARRAY)){
		while(cell!=null && _OBSTACLES[cell]==null && _LEEKS_CELL[cell]==null && getCellDistance(c, cell)<=maxrange){
			push(result, cell);
			cell = getCellFromXY(x, y+minrange+inc++);
		}
	}
	cell = getCellFromXY(x, y-minrange); inc = 1;
	if(cell!=null && _OBSTACLES[cell]==null && _LEEKS_CELL[cell]==null && lineOfSight(c, cell, _EMPTYARRAY)){
		while(cell!=null && _OBSTACLES[cell]==null && _LEEKS_CELL[cell]==null && getCellDistance(c, cell)<=maxrange){
			push(result, cell);
			cell = getCellFromXY(x, y-minrange-inc++);
		}
	}
	return @result;
}

// return lazerTargets array
function getLazerTargetsFromCell(@from, @to, @minrange, @maxrange){
	var xFrom = getCellX(from), yFrom = getCellY(from),
		xTo = getCellX(to), yTo = getCellY(to), result = [],
		inc = 0, maxInc = maxrange-getCellDistance(from, to), tmpCell, tmpContent;
	
	if(xFrom==xTo){
		if(yFrom<yTo){
			// y++
			while(true){
				tmpCell = getCellFromXY(xTo, yTo+inc);
				if(tmpCell == null || _OBSTACLES[tmpCell]!=null || inc > maxInc) break;
				tmpContent = getCellContent(tmpCell);
				if(tmpContent == CELL_PLAYER) push(result, getLeekOnCell(tmpCell));
				inc++;
			}
		}else{
			// y--
			while(true){
				tmpCell = getCellFromXY(xTo, yTo-inc);
				if(tmpCell == null || _OBSTACLES[tmpCell]!=null || inc > maxInc) break;
				tmpContent = getCellContent(tmpCell);
				if(tmpContent == CELL_PLAYER) push(result, getLeekOnCell(tmpCell));
				inc++;
			}
		}
	}else if(yFrom==yTo){
		if(xFrom<xTo){
			// x++
			while(true){
				tmpCell = getCellFromXY(xTo+inc, yTo);
				if(tmpCell == null || _OBSTACLES[tmpCell]!=null || inc > maxInc) break;
				tmpContent = getCellContent(tmpCell);
				if(tmpContent == CELL_PLAYER) push(result, getLeekOnCell(tmpCell));
				inc++;
			}
		}else{
			// x--
			while(true){
				tmpCell = getCellFromXY(xTo-inc, yTo);
				if(tmpCell == null || _OBSTACLES[tmpCell]!=null || inc > maxInc) break;
				tmpContent = getCellContent(tmpCell);
				if(tmpContent == CELL_PLAYER) push(result, getLeekOnCell(tmpCell));
				inc++;
			}
		}
	}
	
	return @result;
}

// renvoie un array de cell depuis lesquel on peut tirer sur cell
// ne fonctionne que pour le leek qui l'utilise, j'utilise leekToIgnore = [getLeek()]
// pour les lignes de vue et _LEEKS pour les cases non accessibles (ou il y a tout le monde sauf le leek)
// donc pas pour les bulbes cette fonction !
function _getCellsToUseWeapChipOnCell(@weapChip, @cell){
	var leekToIgnore = [getLeek()],result = [],
	x = getCellX(cell), y = getCellY(cell),
	minrange = _ITEM_MINRANGE[weapChip],
	maxrange = _ITEM_MAXRANGE[weapChip],
	inline = _ITEM_INLINE[weapChip],
	needlos = _ITEM_NEEDLOS[weapChip];
	for(var x1 = x-maxrange; x1 <= x+maxrange; x1++){
		for(var y1 = y-maxrange; y1 <= y+maxrange; y1++){
			var fromCell = getCellFromXY(x1, y1);
			if(fromCell!=null 
			&& _OBSTACLES[fromCell]==null 
			&& _LEEKS_CELL[fromCell]==null){
				var dist = getCellDistance(fromCell,cell);
				if(dist >= minrange && dist <= maxrange
				&& (!inline || isOnSameLine(fromCell,cell))
				&& (!needlos || lineOfSight(fromCell, cell, leekToIgnore))){
					push(result, fromCell);
				}
			}
		}
	}
	return @result;
}

function bulb_getCellsToUseChipOnCell(@weapChip, @cell){
	var leekToIgnore = [getLeek()],result = [],
	x = getCellX(cell), y = getCellY(cell),
	minrange = _ITEM_MINRANGE[weapChip],
	maxrange = _ITEM_MAXRANGE[weapChip],
	inline = _ITEM_INLINE[weapChip],
	needlos = _ITEM_NEEDLOS[weapChip];
	for(var x1 = x-maxrange; x1 <= x+maxrange; x1++){
		for(var y1 = y-maxrange; y1 <= y+maxrange; y1++){
			var fromCell = getCellFromXY(x1, y1);
			if(fromCell!=null 
			&& _OBSTACLES[fromCell]==null 
			&& !isLeek(fromCell)){
				var dist = getCellDistance(fromCell,cell);
				if(dist >= minrange && dist <= maxrange
				&& (!inline || isOnSameLine(fromCell,cell))
				&& (!needlos || lineOfSight(fromCell, cell, leekToIgnore))){
					push(result, fromCell);
				}
			}
		}
	}
	return @result;
}

function _getCellToUseWeapChipOnCell(@weapChip, @cell){
	var leekToIgnore = [getLeek()],result, mpDist = 100,
	x = getCellX(cell), y = getCellY(cell), isWeap = isWeapon(weapChip),
	minrange = isWeap ? getWeaponMinRange(weapChip) : getChipMinRange(weapChip),
	maxrange = isWeap ? getWeaponMaxRange(weapChip) : getChipMaxRange(weapChip),
	inline = isWeap ? isInlineWeapon(weapChip) : isInlineChip(weapChip),
	needlos = isWeap ? weaponNeedLos(weapChip) : chipNeedLos(weapChip);
	for(var x1 = x-maxrange; x1 <= x+maxrange; x1++){
		for(var y1 = y-maxrange; y1 <= y+maxrange; y1++){
			var fromCell = getCellFromXY(x1, y1);
			if(fromCell!=null 
			&& _OBSTACLES[fromCell]==null 
			&& _LEEKS_CELL[fromCell]==null){
				var dist = getCellDistance(fromCell,cell);
				if(dist >= minrange && dist <= maxrange
				&& (!needlos || lineOfSight(fromCell, cell, leekToIgnore))
				&& (!inline || isOnSameLine(fromCell,cell))){
					if(_SELF_FULLMAP_PATH_DIST[fromCell]!=null && _SELF_FULLMAP_PATH_DIST[fromCell]<mpDist){
						mpDist=_SELF_FULLMAP_PATH_DIST[fromCell];
						result=fromCell;
					}
				}
			}
		}
	}
	return @result;
}

function prepareSetMapActions(){
	atkCellsArea1 = [];
	atkCellsArea2 = [];
	atkCellsArea3 = [];
	defCellsArea1 = [];
	defCellsArea2 = [];
	defCellsArea3 = []; // raz
	for(var e in _ALIVE_ENEMIES){
		var cell = getCell(e);
		atkCellsArea1[cell]=cell;
		atkCellsArea2[cell]=cell;
		atkCellsArea3[cell]=cell;
		for(var c in _areaCells1[cell]){
			atkCellsArea1[c]=c;
			atkCellsArea2[c]=c;
			atkCellsArea3[c]=c;
		}
		for(var c in _areaCells2[cell]){
			atkCellsArea2[c]=c;
			atkCellsArea3[c]=c;
		}
		for(var c in _areaCells3[cell]){
			atkCellsArea3[c]=c;
		}
	}
	for(var e in _ALIVE_ALLIES){
		var cell = getCell(e);
		defCellsArea1[cell]=cell;
		defCellsArea2[cell]=cell;
		defCellsArea3[cell]=cell;
		for(var c in _areaCells1[cell]){
			defCellsArea1[c]=c;
			defCellsArea2[c]=c;
			defCellsArea3[c]=c;
		}
		for(var c in _areaCells2[cell]){
			defCellsArea2[c]=c;
			defCellsArea3[c]=c;
		}
		for(var c in _areaCells3[cell]){
			defCellsArea3[c]=c;
		}
	}
}