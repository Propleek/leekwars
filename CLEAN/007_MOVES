include('auto');

function sayCupidon(){
	var stupidSay = [
		"L'amour ça fait mal !"
		,"Mon coeur saigne..."
		,"Tu me fend le coeur."
		,"J'ai le coeur fendu par toi."
		,"Demain dès l'aube, à l'heure où blanchie la campagne, je partirai..."
		,"Ne courrez pas, nous venons en paix ! pew pew pew !"
		,"Et si l'homme est un chien c'est qu'il est plus fidèle, plus fidèle à des chattes qui se feront la belle !"
		,"Quand dieu créa la mer rouge, il sala mal l'écume."
		,"<3"
		,"Négatif, je suis une mite en pull-over"
		,"Vous allez vous aimer les uns les autres bordel de merde ?!"
	];
	say(stupidSay[randInt(0, count(stupidSay))]);
}

/**
 * Retourne la cellule la plus sure parmis les cellules accessibles
 *
 * @return int Cellule la plus sure
 */
function getSafestCell(){
	var minDanger = 1000000;
	var safestCell = getCell();
	for(var cell: var dist in reachableCells){
		var danger = @map_danger[cell];
		if(danger < minDanger){
			minDanger = danger;
			safestCell = cell;
		}
		else if(danger == minDanger && getDistance(cell, 306) < getDistance(safestCell, 306)){
			minDanger = danger;
			safestCell = cell;
		}
	}
	
	return safestCell;
}

function getPathDistToClosestSafeCellFromCenter(){
	var minDanger = 1000000, myCell = getCell();
	var distFromMe = getReachableCells([myCell:0], 100, []);
	var safestCell = getCell();
	for(var cell: var danger in map_danger){
		if(distFromMe[cell] == null) continue;
		var tmpDanger = danger + getCellDistance(cell, 306) + distFromMe[cell];
		if(tmpDanger < minDanger){
			minDanger = tmpDanger;
			safestCell = cell;
		}
	}
	//mark(safestCell, COLOR_BLUE);
	return @getReachableCells([safestCell:0], 100, [getCell()]);
}

function getClosestReachableSafeCellToEnemy(){
	// des dégâts inférieur à 10% de ma vie quand je suis full life sont acceptable.
	var minDanger = 1000000, minDist = 99, 
	eCell = getCell(getNearestEnemy()), selfCell = getCell(),
	minRisk = getLife()==getTotalLife() ? getLife()*0.1 : 0, finalCell = null;
	for(var cell:var dist in reachableCells){
		var danger = map_danger[cell];
		if(finalCell==null || (danger > minRisk && danger < minDanger)){
			finalCell = cell;
			minDanger = map_danger[cell];
			minDist = getCellDistance(selfCell, cell);
		}else if(danger <= minRisk || danger==minDanger){
			var tmpDist = getCellDistance(selfCell, cell);
			if(tmpDist<minDist){
				finalCell = cell;
				minDanger = map_danger[cell];
				minDist = tmpDist;
			}
		}
	}
	mark(finalCell, COLOR_BLUE);
	return @getReachableCells([finalCell:0], 100, [getCell()]);
}

function getStardardCell(dddddd){
	var safestCell = getCell();
	var enemyCell = getCell(getNearestEnemy());
	var damage = 999999;
	var distToTen = 99999;
	for(var cell:var dist in reachableCells){
		var cellDmg = map_danger[cell];
		if(damage>cellDmg){
			safestCell=cell;
			damage=cellDmg;
			distToTen = abs(dddddd-getCellDistance(safestCell, enemyCell));
		}else if(damage==cellDmg){
			var tmpdist = abs(dddddd-getCellDistance(cell, enemyCell));
			if(tmpdist<distToTen){
				safestCell=cell;
				distToTen=tmpdist;
			}
		}
	}
	mark(safestCell, COLOR_BLUE);
	return @safestCell;
}
