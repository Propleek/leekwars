include('auto');

//debut de chaque tour après avoir init la map de danger
function updateCoef(){
	_COEF_DMG = [];
	_COEF_HEAL = [];
	_COEF_URGENT = [];
	_COEF_ABSSHIELD = [];
	_COEF_RELSHIELD = [];
	_COEF_STR_BOOST = [];
	_COEF_MP_BOOST = [];
	_COEF_TP_BOOST = [];	
 	_COEF_AGI_BOOST = [];
 	_COEF_WSD_BOOST = [];
 	_COEF_RST_BOOST = [];
 	_COEF_SHACKLE_TP = [];
 	_COEF_SHACKLE_MP = [];
 	_COEF_SHACKLE_STR = [];
	_COEF_SHACKLE_MGC = [];
	for(var target in _ALIVE_ALLIES+_ALIVE_ENEMIES){
		var infos = _LEEKS[target];
		var eType = getEntityType(target);
		var lifeRatio = getLife(target)/getTotalLife(target);
		if(isAlly(target)){
			if(eType==ENTITY_LEEK_){
				_COEF_DMG[target] = -2;
				_COEF_HEAL[target] = -1;
				if(lifeRatio<0.9) _COEF_HEAL[target] = -2;
				if(lifeRatio<0.7) _COEF_HEAL[target] = -3;
				// reminder: doit être positif sinon les moins s'annulent !
				_COEF_URGENT[target] = 1;
				if(lifeRatio<0.5) _COEF_URGENT[target] = 2;
				_COEF_ABSSHIELD[target] = -1.4;
				if(infos["absShield"]==0) _COEF_ABSSHIELD[target] = -2.4;
				if(lifeRatio<0.8)_COEF_ABSSHIELD[target]-=1;
				_COEF_RELSHIELD[target] = -1.6;
				if(infos["relShield"]==0) _COEF_RELSHIELD[target] = -2.7;
				if(lifeRatio<0.8)_COEF_RELSHIELD[target]-=1;
				_COEF_STR_BOOST[target] = -1.5;
				if(target!=_SELF) _COEF_STR_BOOST[target] = -2;
				_COEF_MP_BOOST[target] = -2;
				_COEF_TP_BOOST[target] = -2;
				_COEF_AGI_BOOST[target] = -2;
				_COEF_WSD_BOOST[target] = -2;
				_COEF_RST_BOOST[target] = -2;
				_COEF_SHACKLE_TP[target] = -2;
				_COEF_SHACKLE_MP[target] = -2;
				_COEF_SHACKLE_STR[target] = -2;
				_COEF_SHACKLE_MGC[target] = -2;				
			}
			else {//bulb
				_COEF_DMG[target] = -1;
				_COEF_HEAL[target] = -0.8;
				// reminder: doit être positif sinon les moins s'annulent !
				_COEF_URGENT[target] = 1;
				_COEF_ABSSHIELD[target] = -1;
				_COEF_RELSHIELD[target] = -1;
				_COEF_STR_BOOST[target] = -1;
				_COEF_MP_BOOST[target] = -1;
				_COEF_TP_BOOST[target] = -1;
				_COEF_AGI_BOOST[target] = -1;
				_COEF_WSD_BOOST[target] = -1;
				_COEF_RST_BOOST[target] = -1;
				_COEF_SHACKLE_TP[target] = -1;
				_COEF_SHACKLE_MP[target] = -1;
				_COEF_SHACKLE_STR[target] = -1;
				_COEF_SHACKLE_MGC[target] = -1;
				
			}
		}else{//enemy
			_COEF_HEAL[target] = 2;
			_COEF_URGENT[target] = 1;
			_COEF_ABSSHIELD[target] = 2;
			_COEF_RELSHIELD[target] = 2;
			_COEF_STR_BOOST[target] = 2;
			_COEF_MP_BOOST[target] = 2;
			_COEF_TP_BOOST[target] = 2;
			_COEF_AGI_BOOST[target] = 2;
			_COEF_WSD_BOOST[target] = 2;
			_COEF_RST_BOOST[target] = 2;
			if(eType==ENTITY_LEEK_){
				_COEF_DMG[target] = 2;
				if(getTurn()>30) _COEF_DMG[target] = 3;
				if(lifeRatio<0.6)_COEF_DMG[target]+= 1;
				_COEF_SHACKLE_TP[target] = 2;
				_COEF_SHACKLE_MP[target] = 2;
				_COEF_SHACKLE_STR[target] = 2;
				_COEF_SHACKLE_MGC[target] = 2;
			}
			else{//bulb
				_COEF_DMG[target] = 0.8;
				_COEF_SHACKLE_TP[target] = 0.5;
				_COEF_SHACKLE_MP[target] = 0.5;
				_COEF_SHACKLE_STR[target] = 0.5;
				_COEF_SHACKLE_MGC[target] = 0.5;
			}
				
		}
	}
}
                 
// TODO liberate remove reduc.
function getVirtualState(@leek, @stackOfResult){
    var state = _LEEKS[leek];
	if(stackOfResult[leek]==null) return @state;
	if(stackOfResult["debuff"]==true){
		state["psnlife"] = state["life"];
		state["psnTurn"] = 0;
		state["psnTotal"] = 0;
		state["absShield"] = 0;
		state["relShield"] = 0;
	}
	if(stackOfResult["antidote"]==true){
		state["psnlife"] = state["life"];
		state["psnTurn"] = 0;
		state["psnTotal"] = 0;
	}
	state["absShield"]+=stackOfResult[leek]["absShield"];
	state["relShield"]+=stackOfResult[leek]["relShield"];
    state["life"]-=stackOfResult[leek]["dmg"]; // dmg
    state["life"]+=stackOfResult[leek]["heal"]; // heal
    if(state["totallife"]<state["life"])state["life"]=state["totallife"];
    state["psnlife"]-=stackOfResult[leek]["psn"];
	state["psnTurn"]+=stackOfResult[leek]["psn"];
    return @state;
}

function getScoreOfAction(@action, @stackOfResult, @stackOfDeath){
    var me = @_LEEKS[_SELF],
	myStr = me["str"],
    myMgc = me["mgc"],
    myWis = me["wsd"],
	myRst = me["rst"],
	mySnc = me["snc"],
	myAbsShield = me["absShield"],
	myRelShield = me["relShield"],
    item = action["item"],
    lifeMissing = me["totallife"]-me["life"],
    area = _ITEM_AREA[item],
    isAOE = area==AREA_CIRCLE_1||area==AREA_CIRCLE_2||area==AREA_CIRCLE_3,
    effects = @_ITEM_EFFECTS[item],
    score = 0,
	from = action["from"],
	to = action["to"],
	isSelf = from==to;
 	if(item == CHIP_DRIP && getCellDistance(from, to)<=2){
		if(!inArray(action["targets"], _SELF)) push(action["targets"], _SELF);
		isSelf=true;
	}
    for(var target in action["targets"]){
        if(target==_SELF && !isSelf) continue; // ignore self, je suis pas sur la case ici !
        if(stackOfDeath[target]!=null) continue; // si la cible est déjà morte, next !
        var virtualTargetState = getVirtualState(target, stackOfResult);
        var dmgRatio = isAOE? getDamagePercentage(getCell(target), to, area) : 100;

        var minDmgValue=0, avgDmgValue=0, turnPsn=0, avgPsn=0, healValue=0, absShieldValue=0, relShieldValue=0, boostStrValue=0, boostAgiValue=0, boostTPValue=0, boostMPValue=0, lifeSteal=0, shackleTPValue=0, shackleMPValue=0, shackleStrValue=0, shackleMgcValue=0, debuffValue=0, antidoteValue=0;
		var duration;
        for(var e in effects){
			var type = e[0];
			var min = e[1];
			var max = e[2];
			var moy = (min+max)/2;
			var optimistmoy = (max+moy)/2;
			var pessimistmoy = (min+moy)/2;
			duration = e[3];
            if(type == EFFECT_DAMAGE){
                minDmgValue += ( pessimistmoy*(1+(myStr/100))
                    *(1-(virtualTargetState["relShield"]/100))
                    *(dmgRatio/100)) - virtualTargetState["absShield"];
                avgDmgValue += (optimistmoy*(1+(myStr/100))
                    *(1-(virtualTargetState["relShield"]/100))
                    *(dmgRatio/100)) - virtualTargetState["absShield"];
            }
            else if(type == EFFECT_POISON){
                turnPsn += pessimistmoy*(1+(myMgc/100))*(dmgRatio/100);
                avgPsn += moy*(1+(myMgc/100))*(dmgRatio/100) *duration;
				// 1tour de moins que le max.
                // soit 100%, 67%, 33% sur 3 tours vu les effects de heal/libération.
            }
            else if(type == EFFECT_HEAL){
                healValue = moy*(1+(myWis/100))*(dmgRatio/100);
            }
			else if(type == EFFECT_BOOST_MAX_LIFE){
				healValue = optimistmoy*(1+(myWis/100))*(dmgRatio/100);
				// TODO gérer autrement en donnant double valeur aux points et sans passer par healValue qui est capé au maxhp dela cible.
			}
			else if(type == EFFECT_ABSOLUTE_SHIELD){
				// todo isAlreadyOnEffect avec global state
				absShieldValue = moy*(1+(myRst/100))*(dmgRatio/100);
			}
			else if(type == EFFECT_RELATIVE_SHIELD){
				relShieldValue = moy*(1+(myRst/100))*(dmgRatio/100);
			}
			else if(type == EFFECT_BUFF_STRENGTH){
				boostStrValue = moy*(1+(mySnc/100))*(dmgRatio/100)*duration;
			}
			else if(type == EFFECT_BUFF_AGILITY
			|| type == EFFECT_BUFF_WISDOM
			|| type == EFFECT_BUFF_RESISTANCE){
				boostAgiValue = moy*(1+(mySnc/100))*(dmgRatio/100)*duration;
				// un seul test pour la simplcité pour le moment.
			}
			else if(type == EFFECT_BUFF_MP){
				boostMPValue = round(moy*(1+(mySnc/100))*(dmgRatio/100))*duration;
			}
			else if(type == EFFECT_BUFF_TP){
				boostTPValue = round(moy*(1+(mySnc/100))*(dmgRatio/100))*duration;
			}
			else if(type == EFFECT_SHACKLE_TP){
				shackleTPValue = round(pessimistmoy*(1+(myMgc-virtualTargetState["snc"])/100)*(dmgRatio/100));
			}
			else if(type == EFFECT_SHACKLE_MP){
				shackleMPValue = round(pessimistmoy*(1+(myMgc-virtualTargetState["snc"])/100)*(dmgRatio/100));
			}
			else if(type == EFFECT_SHACKLE_STRENGTH){
				shackleStrValue = round(pessimistmoy*(1+(myMgc-virtualTargetState["snc"])/100)*(dmgRatio/100));
			}
			else if(type == EFFECT_SHACKLE_MAGIC){
				shackleMgcValue = round(pessimistmoy*(1+(myMgc-virtualTargetState["snc"])/100)*(dmgRatio/100));
			}
			else if(type == EFFECT_DEBUFF){ // LIBERATION !
				var eeee = @_LEEKS[target]["effects"];
				for(var ef in eeee){
					debuffValue += ef;
				}
				debuffValue -= _LEEKS[_SELF]["psnTurn"];
			}
			else if(type == EFFECT_ANTIDOTE){
				antidoteValue= virtualTargetState["psnTotal"];	
			}
            else{
			//TODO:
			/*EFFECT_KILL*/	
    //debugE("unhandled:"+getWeaponName(action["item"])+getChipName(action["item"]));
            }
        }
        //kill?
        // ici maybe check if damage pas < à 0 !
		//TODO dans le kill et le normal, faire les revoies de dégâts !
        if(virtualTargetState["life"]<=minDmgValue){
            minDmgValue=virtualTargetState["life"];
            stackOfDeath[target]=target;
            score+=minDmgValue*_COEF_DMG[target];
            //lifesteal
            lifeSteal+=minDmgValue*myWis/1000;
            if(lifeSteal>0){
                if(lifeSteal>lifeMissing)lifeSteal=lifeMissing;
                lifeMissing-=lifeSteal;
                score+=lifeSteal*_COEF_HEAL[_SELF]*_COEF_URGENT[_SELF];
                stackOfResult[_SELF]["heal"]+=lifeSteal;
            }
            //lifestealend
        }else if(virtualTargetState["psnlife"]-minDmgValue <= turnPsn){
            stackOfDeath[target]=target;
            score+=turnPsn*_COEF_DMG[target];
        }else{
            if(stackOfResult[target]==null)stackOfResult[target]=[];
            if(avgDmgValue){
                stackOfResult[target]["dmg"]+=minDmgValue; // sauvegarde du min
                score +=avgDmgValue*_COEF_DMG[target]; // score de l'avg
                //lifesteal
                lifeSteal+=avgDmgValue*myWis/1000;
                if(lifeSteal){
                    if(lifeSteal>lifeMissing)lifeSteal=lifeMissing;
                    lifeMissing-=lifeSteal;
                    score+=lifeSteal*_COEF_HEAL[_SELF]*_COEF_URGENT[_SELF];
                    stackOfResult[_SELF]["heal"]+=lifeSteal;
                }
                //lifestealend
            }
            if(avgPsn){
                stackOfResult[target]["psn"]+=turnPsn;
                score +=avgPsn*_COEF_DMG[target];
            }
            if(healValue){
				if(item==CHIP_VACCINE){
					var onEffect = _LEEKS[target]["effects"][item];
					if(onEffect != null) score+=onEffect*_COEF_HEAL[target];
					if(stackOfResult[target]["psnTurn"]==null) stackOfResult[target]["psnTurn"]=0;
					stackOfResult[target]["psnTurn"] -=healValue;
					score -=healValue*duration/2*_COEF_HEAL[target];
				}else{
					var totallife = virtualTargetState["totallife"];
					var targetMissingLife = totallife-virtualTargetState["life"];
					if(healValue>targetMissingLife) healValue=targetMissingLife;
					if(item==CHIP_REGENERATION){
						if(targetMissingLife>healValue){
							stackOfResult[target]["heal"]+=healValue;
							score -=healValue*_COEF_HEAL[target]*_COEF_URGENT[target];
						}else{
							score -=200;
						}
					}else{
						stackOfResult[target]["heal"]+=healValue;
						score -=healValue*_COEF_HEAL[target]*_COEF_URGENT[target];
					}
				}
            }
			if(absShieldValue){
				// astuce team Tay
				var onEffect = _LEEKS[target]["effects"][item];
				if(onEffect != null) score+=onEffect*_COEF_ABSSHIELD[target];
				if(stackOfResult[target]["absShield"]<=0) score+=50;
				stackOfResult[target]["absShield"]+=absShieldValue;
				score -=absShieldValue*duration/2*_COEF_ABSSHIELD[target];
				if(!_SCN_STR_100) score = 1;// todo del this & handle in coef.
			}
			if(relShieldValue){
				var onEffect = _LEEKS[target]["effects"][item];
				if(onEffect != null) score+=onEffect*4*_COEF_RELSHIELD[target];
				if(stackOfResult[target]["relShield"]<=0) score +=50;
				stackOfResult[target]["relShield"]+=relShieldValue;
				score -=relShieldValue*duration*2*_COEF_RELSHIELD[target];
				//*4/2=*2 pour que 30% d'armure soit == à 120 armor abs environ
				// je pense que ce c'est discutable, selon les dégâts potentiels de l'adversaire, ptete faire un calcul en début de tour du "potentiel agressif" de la team en face en terme de force/science/magie pour orienter les choix ?
				if(!_SCN_STR_200) score = 1;
			}
			if(boostStrValue){
				//TODO gestion des stats dans la stack, pareillement qu'au dessus pour des kills de forains en mode boostkill pour le pv manquant.
				var onEffect = _LEEKS[target]["effects"][item];
				if(onEffect != null) score+=onEffect*_COEF_STR_BOOST[target];
				score -= boostStrValue*_COEF_STR_BOOST[target];
			}
			if(boostAgiValue){
				var onEffect = _LEEKS[target]["effects"][item];
				if(onEffect != null) score+=onEffect*_COEF_AGI_BOOST[target];
				score -= boostAgiValue*_COEF_AGI_BOOST[target];
			}
			if(boostMPValue){
				var onEffect = _LEEKS[target]["effects"][item];
				if(onEffect != null) score+=onEffect*40*_COEF_MP_BOOST[target];
				score -= boostMPValue*30*_COEF_MP_BOOST[target];//1mp=30str
			}
			if(boostTPValue){
				var onEffect = _LEEKS[target]["effects"][item];
				if(onEffect != null) score+=onEffect*50*_COEF_TP_BOOST[target];
				score -= boostTPValue*40*_COEF_TP_BOOST[target];//1tp=40str
			}
			if(shackleTPValue){
				score += shackleTPValue*50*_COEF_SHACKLE_TP[target];//50 en shackle aussi
			}
			if(shackleMPValue){
				score += shackleMPValue*30*_COEF_SHACKLE_MP[target];//30 en shackle
			}
			if(shackleStrValue){
				score += shackleStrValue*_COEF_SHACKLE_STR[target];
			}
			if(shackleMgcValue){
				score += shackleMgcValue*_COEF_SHACKLE_MGC[target];
			}
			if(debuffValue){
				stackOfResult[target]["debuff"]=true;
				score += debuffValue;
			}
			if(antidoteValue){
				stackOfResult[target]["antidote"]=true;
				score -= antidoteValue*_COEF_HEAL[target]*_COEF_URGENT[target];
			}
        }
    }
    return @score;
}

function addActionToMAPS(@item, @from, @to, @targets){
	var dist = reachableCells[from];
    if(dist==null)return; // filtering all action I can't reach
	if(assoc_weap_from[item]==null) assoc_weap_from[item] = [];
	push(assoc_weap_from[item], from);
	
	if(assoc_from_item_actions[from]==null) assoc_from_item_actions[from] = [];
	if(assoc_from_item_actions[from][item]==null) assoc_from_item_actions[from][item] = [];
	
	var action = ["item":item, "from":from, "to":to, "targets":targets];
	push(assoc_from_item_actions[from][item], action);
}

function setMapActions(){
	updateCoef();
	self_action_array = []; // clear
	assoc_weap_from = []; // clear
	assoc_from_item_actions = [];//clear
    var self = getLeek(), interest;
    for(var w in getWeapons()){
        var weaponArea = _ITEM_AREA[w];    
        if(weaponArea == AREA_POINT){ // normal cible unique.
            for(var target in getAliveEnemies()){ // pas d'ally susceptible d'être une cible.
                var toCell = getCell(target);
                var targets = [target];
                for(var from in _getCellsToUseWeapChipOnCell(w, toCell)){
                    addActionToMAPS(w, from, toCell, targets);
                }
            }
        }else if(weaponArea == AREA_LASER_LINE){ // cas d'un lazer
			var minrange = _ITEM_MINRANGE[w];
	        var maxrange = _ITEM_MAXRANGE[w];
            for(var fromCell = 0; fromCell < 613; fromCell++){
                if(_OBSTACLES[fromCell]==null){
                    for(var toCell in getLazerTargetsCell(fromCell, minrange)){
                        var targets = getLazerTargetsFromCell(fromCell, toCell, minrange, maxrange);
                        if(count(targets)>0){// ici du coup je rend le b_lazer useless
                            interest=0; // du fait de la simplification du test
                            for(var t in targets) interest+=_COEF_DMG[t];
                            if(interest>0) addActionToMAPS(w, fromCell, toCell, targets);
                        }
                    }
                }
            }
        }else{// cas des aoe AREA_CIRCLE_X (1, 2, 3)
        // TODO maybe opti en faisant qu'une fois les calcs par area pour weapon & chip
            for(var i = 0; i < 613; i++){
                if(_OBSTACLES[i]==null){
                    var targets = getWeaponTargets(w, i);
                    if(count(targets)>0){
                        interest=0;
                        for(var t in targets)
                            interest+=_COEF_DMG[t]*getDamagePercentage(i, getCell(t), weaponArea)/100;
                        if(interest>0) for(var from in _getCellsToUseWeapChipOnCell(w, i)){
                            addActionToMAPS(w, from, i, targets);
                        }
                    }
                }
            }
        }
    }// end for weapons
    for(var c in getChips()){
        if(getCooldown(c)!=0 || isSpecialChip(c)) continue;
        // pour le moment on gère pas les special chip
        var chipArea = _ITEM_AREA[c];
        // cannot be lazer_line
        if(chipArea==AREA_POINT){
            var targets = isPositivChip(c) ? getAliveAllies() : getAliveEnemies();
			for(var target in targets){
				// self_actions !
                if(target==_SELF && _ITEM_MINRANGE[c]==0 && self_action_array[c]==null){
					self_action_array[c] = c;
				}else if(target!=_SELF){	// others.
					var toCell = getCell(target);
					for(var from in _getCellsToUseWeapChipOnCell(c, toCell)){
						addActionToMAPS(c, from, toCell, [target]);
					}
				}
            }
        }else if(chipArea==AREA_LASER_LINE){
            debugE("CHIP LAZERLINE ?!?");
        }else{// cas des aoe AREA_CIRCLE_X (1, 2, 3)
        // TODO maybe opti en faisant qu'une fois les calcs par area pour weapon & chip
            var isPositiv = isPositivChip(c);
            for(var i = 0; i < 613; i++){
                if(_OBSTACLES[i]==null){
                    var targets = getChipTargets(c, i);
                    if(count(targets)>0){
                        interest=0;
                        for(var t in targets){
						// FIXME DMG ???? est-ce que je prend pas en fonction de l'effet de la puce ? mais ça va couté un bras ?
                            if(isPositiv)interest -= _COEF_DMG[t]* getDamagePercentage(i, getCell(t), chipArea)/100;
                            else interest += _COEF_DMG[t]* getDamagePercentage(i, getCell(t), chipArea)/100;
                        }
                        if(interest>0) for(var from in _getCellsToUseWeapChipOnCell(c, i)){
                            addActionToMAPS(c, from, i, targets);
                        }
                    }
                }
            }
        }
    }//end for chips
}

function findBestMove(@allCombos, @gravityCenter, @distToEnemy){
	var _BESTMOVE=null;
	var enemyCell = getCell(getNearestEnemy());
	var selfCell = getCell();
	var selfMP = getMP();
	var selfLife = getLife();
	var limitMassivDanger = getTotalLife()*0.6;
	var lifePercent = selfLife/getTotalLife();
	
	for(var combo in allCombos){
		var fromArray = [];
		// find cells where every part of combo can be done.
		for(var c=0; c<=612; c++){
			if(_OBSTACLES[c]!=null) continue;
			var ok = true;
			for(var item in combo){
				if(assoc_from_item_actions[c][item]==null
				&& self_action_array[item]==null){
					ok = false;
					break;
				}
			}
			if(ok) push(fromArray, c);
		}

		for(var aCell in fromArray){
			var mpMove1 = reachableCells[aCell];
			var mpLeft = selfMP - mpMove1;
			if(mpMove1 != null && mpLeft >= 0){
				var score = 0, tmpScore = 0, best = [], total;
				var stack = [], dead = [];
				// calcul du score de la meilleure combo depuis cette case.
				for(var item in combo){
					// meilleure score pour chaque item
					var actions = @assoc_from_item_actions[aCell][item];
					var aScore = 0, aBest, aStack, aDead;
					if(actions!=null){
						for(var action in actions){
							var tmpstack=stack, tmpdead=dead;
							tmpScore=getScoreOfAction(action, tmpstack, tmpdead);
							if(aBest == null || aScore < tmpScore){
								aScore = tmpScore;
								aBest = action;
								aStack = tmpstack;
								aDead = tmpdead;
							}
						}
					}//si actions est null, alors self_action ne peut pas être null.
					if(self_action_array[item]!=null){
						var tmpstack=stack, tmpdead=dead;
						//creation d'une action self sur cette case.
						var action = ["item":item, 
						"from":aCell, "to":aCell,
						"targets":[_SELF]];
						tmpScore=getScoreOfAction(action, tmpstack, tmpdead);
						if(aBest == null || aScore < tmpScore){
							aScore = tmpScore;
							aBest = action;
							aStack = tmpstack;
							aDead = tmpdead;
						}
					}
					if(aBest != null && aScore>0){
						aBest["score"] = aScore; // pour le debug
						push(best, aBest);
						stack = aStack;
						dead = aDead;
						score += aScore;
					}else{
						//l'action n'a pas été push car inutile, les TP restant sont libre pour lancer un buff
						//mayeb faire autrement, je laisse le commentaire ici.
					}
				}
				// à partir du score de la meilleure combo depuis aCell, recherche de la meilleure case safe.
				var ignored = [selfCell];
				for(var d in dead) push(ignored, getCell(d));
				var reachable = getReachableCells([aCell:0], mpLeft, ignored);

				// choix de la safestCell
				var minDanger = 9999999;
				var safestCell;
				for(var sCell:var mpused in reachable){
					var danger = getCellDanger(sCell, dead);
					if(safestCell==null || minDanger > danger){
						safestCell = sCell;
						minDanger = danger;
					}
				}

				var finalScore = score; // en dmg 
				for(var d in dead) finalScore += 100*_COEF_DMG[d];// bonus kill
				var risk = minDanger/_MAX_DANGER*120; // - risque ramener sur 100
				if(minDanger > limitMassivDanger) risk*2;
				if(minDanger >= selfLife) finalScore -= 1000; // malus death.
				if(lifePercent<0.6)risk*=2;
				else if(stack[_SELF]["absShield"]>0)risk/2;
				finalScore-= risk;
				finalScore-= getCellDistance(gravityCenter, safestCell);
				var distToE = abs(distToEnemy-getCellDistance(enemyCell, safestCell));
				finalScore-= distToE;

				if(_BESTMOVE==null || _BESTMOVE["score"]<finalScore) _BESTMOVE = [
					"score":finalScore,
					"actions":best,
					//"aCell":aCell,
					"sCell":safestCell,
					"stack":stack,//pour le debuging
					"dead":dead//pour le debuging
				];
				if(getOperations()>OPERATIONS_LIMIT*0.95){
					debug("breaked on combo : " + combo);
					return @_BESTMOVE;
				}
			}
		}
	}
	return @_BESTMOVE;
}

function playBestMove(bestMove){
	//moveTowardCell(bestMove["aCell"]);
	for(var action in bestMove["actions"]){
		debug("SCORE: "+action["score"]);
		var item = action["item"], from = action["from"], to = action["to"];
		moveTowardCell(from);
		if(_ITEM_ISWEAP[item]){
			if(getWeapon()!=item) setWeapon(item);
			useWeaponOnCell(to);
		}
		else useChipOnCell(item, to);
		
		// on compte les utilisations :
		var reg = getRegister(_ITEMID_TOSTRING[item]);
		if(reg==null)setRegister(_ITEMID_TOSTRING[item],1);
		else setRegister(_ITEMID_TOSTRING[item],number(reg)+1);
	}
	moveTowardCell(bestMove["sCell"]);
}
