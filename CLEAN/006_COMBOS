include('auto');

//debut de chaque tour après avoir init la map de danger
function updateCoef(){
	_COEF_DMG = [];
	_COEF_HEAL = [];
	_COEF_URGENT = [];
	_COEF_ABSSHIELD = [];
	_COEF_RELSHIELD = [];
	_COEF_STR_BOOST = [];
	_COEF_MP_BOOST = [];
	_COEF_TP_BOOST = [];	
 	_COEF_AGI_BOOST = [];
 	_COEF_WSD_BOOST = [];
 	_COEF_RST_BOOST = [];
 	_COEF_SHACKLE_TP = [];
 	_COEF_SHACKLE_MP = [];
 	_COEF_SHACKLE_STR = [];
	_COEF_SHACKLE_MGC = [];
	var somme_life_ally = 0;
	var somme_life_enemy= 0;
	var count_ally = 0;
	var count_enemy= 0;
	for(var target in _ALIVE_ALLIES+_ALIVE_ENEMIES){
		var infos = _LEEKS[target];
		var eType = getEntityType(target);
		var lifeRatio = getLife(target)/getTotalLife(target);
		if(isAlly(target)){
			if(eType==ENTITY_LEEK_){
				somme_life_ally+=infos["life"]; // SUM LIFE ALLY
				count_ally++; // COUNT ALLY LEEK
				_COEF_DMG[target] = -2;
				_COEF_HEAL[target] = -1;
				if(lifeRatio<0.9) _COEF_HEAL[target] = -1.5;
				if(lifeRatio<0.7) _COEF_HEAL[target] = -2;
				// reminder: doit être positif sinon les moins s'annulent !
				_COEF_URGENT[target] = 1;
				if(lifeRatio<0.6) _COEF_URGENT[target] = 1.5;
				if(lifeRatio<0.4) _COEF_URGENT[target] = 2;
				_COEF_ABSSHIELD[target] = -1;
				if(infos["absShield"]==0) _COEF_ABSSHIELD[target]+= -0.2;
				if(target!=_SELF) _COEF_ABSSHIELD[target]+= -0.1;
				if(lifeRatio<0.8)_COEF_ABSSHIELD[target]+= -0.4;
				_COEF_RELSHIELD[target] = -1;
				if(target!=_SELF) _COEF_RELSHIELD+= -0.1;
				if(infos["relShield"]==0) _COEF_RELSHIELD[target] += -0.4;
				if(lifeRatio<0.8)_COEF_RELSHIELD[target]+= -0.4;
				_COEF_STR_BOOST[target] = -0.6-(infos["str"]/1000);
				if(target!=_SELF) _COEF_STR_BOOST[target] += -0.1;
				_COEF_MP_BOOST[target] = -1.7;
				_COEF_TP_BOOST[target] = -1.7;
				_COEF_AGI_BOOST[target] = -2;
				_COEF_WSD_BOOST[target] = -2;
				_COEF_RST_BOOST[target] = -2;
				_COEF_SHACKLE_TP[target] = -3;
				_COEF_SHACKLE_MP[target] = -2;
				_COEF_SHACKLE_STR[target] = -2;
				_COEF_SHACKLE_MGC[target] = -2;				
			}
			else {//bulb
				//somme_life_ally+=infos["life"]; // ???
				_COEF_DMG[target] = -1;
				_COEF_HEAL[target] = -0.8;
				// reminder: doit être positif sinon les moins s'annulent !
				_COEF_URGENT[target] = 1;
				_COEF_ABSSHIELD[target] = -1;
				_COEF_RELSHIELD[target] = -1;
				_COEF_STR_BOOST[target] = -1;
				_COEF_MP_BOOST[target] = -1;
				_COEF_TP_BOOST[target] = -1;
				_COEF_AGI_BOOST[target] = -1;
				_COEF_WSD_BOOST[target] = -1;
				_COEF_RST_BOOST[target] = -1;
				_COEF_SHACKLE_TP[target] = -1;
				_COEF_SHACKLE_MP[target] = -1;
				_COEF_SHACKLE_STR[target] = -1;
				_COEF_SHACKLE_MGC[target] = -1;
			}
		}else{//enemy
			somme_life_enemy+=infos["life"]; // SUM LIFE ENEMY
			_COEF_HEAL[target] = 2;
			_COEF_URGENT[target] = 1;
			_COEF_ABSSHIELD[target] = 2;
			_COEF_RELSHIELD[target] = 2;
			_COEF_STR_BOOST[target] = 2;
			_COEF_MP_BOOST[target] = 2;
			_COEF_TP_BOOST[target] = 2;
			_COEF_AGI_BOOST[target] = 2;
			_COEF_WSD_BOOST[target] = 2;
			_COEF_RST_BOOST[target] = 2;
			if(eType==ENTITY_LEEK_){
				count_enemy++; // COUNT ENEMY LEEK
				_COEF_DMG[target] = 2;
				if(getTurn()>30) _COEF_DMG[target] += 0.5;
				if(getTurn()>50) _COEF_DMG[target] += 0.5;
				if(lifeRatio<0.6)_COEF_DMG[target]+= 1;
				if(getLevel(target)<getLevel()/2) _COEF_DMG[target] -= 1;
				_COEF_SHACKLE_TP[target] = 2;
				_COEF_SHACKLE_MP[target] = 2;
				_COEF_SHACKLE_STR[target] = 2;
				_COEF_SHACKLE_MGC[target] = 2;
			}
			else{//bulb
				count_enemy+=0.5;// COUNT ENEMY BULB
				if(eType==ENTITY_PUNY_BULB) _COEF_DMG[target] = 0.5;
				else _COEF_DMG[target] = 1.2;
				_COEF_SHACKLE_TP[target] = 0.5;
				_COEF_SHACKLE_MP[target] = 0.5;
				_COEF_SHACKLE_STR[target] = 0.5;
				_COEF_SHACKLE_MGC[target] = 0.5;
			}
		}
	}// end for(var target in alive)
	// fix des vals global
	var ratioPv = somme_life_ally/somme_life_enemy;
	if(ratioPv > 2) _RATIO_DANGER = 0.5;
	else _RATIO_DANGER = 1;
	var ratioCount = count_ally/count_enemy;
	if(ratioCount > 2) _RATIO_IGNORE_DANGER = 0.5;
	else _RATIO_IGNORE_DANGER = 0.25;
	// au cas ou je veux modif ça un jour...
	//_SCORE_KILL_DMG = 100;
	//_SCORE_KILL_PSN = 50;
	//_SCORE_DEATH = 1000;
}
                 
// TODO liberate remove reduc.
function getVirtualState(@leek, @stackOfResult){
    var state = _LEEKS[leek];
	if(stackOfResult[leek]==null) return @state;
	if(stackOfResult["debuff"]==true){
		state["psnlife"] = state["life"];
		state["psnTurn"] = 0;
		state["psnTotal"] = 0;
		state["absShield"] = 0;
		state["relShield"] = 0;
	}
	if(stackOfResult["antidote"]==true){
		state["psnlife"] = state["life"];
		state["psnTurn"] = 0;
		state["psnTotal"] = 0;
	}
	state["absShield"]+=stackOfResult[leek]["absShield"];
	state["relShield"]+=stackOfResult[leek]["relShield"];
	state["str"]+=stackOfResult[leek]["str"];
    state["life"]-=stackOfResult[leek]["dmg"]; // dmg
    state["life"]+=stackOfResult[leek]["heal"]; // heal
    if(state["totallife"]<state["life"])state["life"]=state["totallife"];
    state["psnlife"]-=stackOfResult[leek]["psn"];
	state["psnTurn"]+=stackOfResult[leek]["psn"];
    return @state;
}

function getScoreOfAction(@action, @stackOfResult, @stackOfDeath){
    var me = getVirtualState(_SELF, stackOfResult),
	myStr = me["str"],
    myMgc = me["mgc"],
    myWis = me["wsd"],
	myRst = me["rst"],
	mySnc = me["snc"],
	myAbsShield = me["absShield"],
	myRelShield = me["relShield"],
    item = action["item"],
    lifeMissing = me["totallife"]-me["life"],
    area = _ITEM_AREA[item],
    isAOE = area==AREA_CIRCLE_1||area==AREA_CIRCLE_2||area==AREA_CIRCLE_3,
    effects = @_ITEM_EFFECTS[item],
    score = 0,
	from = action["from"],
	to = action["to"],
	isSelf = from==to;
 	if(item == CHIP_DRIP && getCellDistance(from, to)<=2){
		if(!inArray(action["targets"], _SELF)) push(action["targets"], _SELF);
		isSelf=true;
	}
    for(var target in action["targets"]){
        if(target==_SELF && !isSelf) continue; // ignore self, je suis pas sur la case ici !
        if(stackOfDeath[target]!=null) continue; // si la cible est déjà morte, next !
        var virtualTargetState = getVirtualState(target, stackOfResult);
        var dmgRatio = isAOE? getDamagePercentage(getCell(target), to, area) : 100;

        var minDmgValue=0, avgDmgValue=0, turnPsn=0, avgPsn=0, healValue=0, maxhpValue=0, absShieldValue=0, relShieldValue=0, boostStrValue=0, boostAgiValue=0, boostTPValue=0, boostMPValue=0, lifeSteal=0, shackleTPValue=0, shackleMPValue=0, shackleStrValue=0, shackleMgcValue=0, debuffValue=0, antidoteValue=0;
        for(var e in effects){
			var type = e[0];
			var min = e[1];
			var max = e[2];
			var moy = (min+max)/2;
			var optimistmoy = (max+moy)/2;
			var pessimistmoy = (min+moy)/2;
			var duration = e[3];
			duration = duration == 0 ? 1 : // 0 => 1 
				(duration == 3 ? 2.5 : // 3 => 2.5
				(duration == 4 ? 3 : // 4 => 3
				duration)); // 1 => 1 && 2 => 2
            if(type == EFFECT_DAMAGE){
                minDmgValue += ( pessimistmoy*(1+(myStr/100))
                    *(1-(virtualTargetState["relShield"]/100))
                    *(dmgRatio/100)) - virtualTargetState["absShield"];
                avgDmgValue += (optimistmoy*(1+(myStr/100))
                    *(1-(virtualTargetState["relShield"]/100))
                    *(dmgRatio/100)) - virtualTargetState["absShield"];
            }
            else if(type == EFFECT_POISON){
                turnPsn += pessimistmoy*(1+(myMgc/100))*(dmgRatio/100);
                avgPsn += moy*(1+(myMgc/100))*(dmgRatio/100) *duration;
				// 1tour de moins que le max.
                // soit 100%, 67%, 33% sur 3 tours vu les effects de heal/libération.
            }
            else if(type == EFFECT_HEAL){
                healValue = moy*(1+(myWis/100))*(dmgRatio/100)*duration;
            }
			else if(type == EFFECT_BOOST_MAX_LIFE){
				maxhpValue = moy*(1+(myWis/100))*(dmgRatio/100);
			}
			else if(type == EFFECT_ABSOLUTE_SHIELD){
				// todo isAlreadyOnEffect avec global state
				absShieldValue = moy*(1+(myRst/100))*(dmgRatio/100)*duration;
			}
			else if(type == EFFECT_RELATIVE_SHIELD){
				relShieldValue = moy*(1+(myRst/100))*(dmgRatio/100)*duration;
			}
			else if(type == EFFECT_BUFF_STRENGTH){
				boostStrValue = moy*(1+(mySnc/100))*(dmgRatio/100)*duration;
			}
			else if(type == EFFECT_BUFF_AGILITY
			|| type == EFFECT_BUFF_WISDOM
			|| type == EFFECT_BUFF_RESISTANCE){
				boostAgiValue = moy*(1+(mySnc/100))*(dmgRatio/100)*duration;
				// un seul test pour la simplcité pour le moment.
			}
			else if(type == EFFECT_BUFF_MP){
				boostMPValue = round(moy*(1+(mySnc/100))*(dmgRatio/100))*duration;
			}
			else if(type == EFFECT_BUFF_TP){
				boostTPValue = round(moy*(1+(mySnc/100))*(dmgRatio/100))*duration;
			}
			else if(type == EFFECT_SHACKLE_TP){
				shackleTPValue = round(pessimistmoy*(1+(myMgc-virtualTargetState["snc"])/100)*(dmgRatio/100))*duration;
			}
			else if(type == EFFECT_SHACKLE_MP){
				shackleMPValue = round(pessimistmoy*(1+(myMgc-virtualTargetState["snc"])/100)*(dmgRatio/100))*duration;
			}
			else if(type == EFFECT_SHACKLE_STRENGTH){
				shackleStrValue = round(moy*(1+(myMgc-virtualTargetState["snc"])/100)*(dmgRatio/100))*duration;
			}
			else if(type == EFFECT_SHACKLE_MAGIC){
				shackleMgcValue = round(moy*(1+(myMgc-virtualTargetState["snc"])/100)*(dmgRatio/100))*duration;
			}
			else if(type == EFFECT_DEBUFF){ // LIBERATION !
				var eeee = @_LEEKS[target]["effects"];
				for(var ef in eeee){
					debuffValue += ef;
				}
				debuffValue -= _LEEKS[_SELF]["psnTurn"];
			}
			else if(type == EFFECT_ANTIDOTE){
				antidoteValue= virtualTargetState["psnTotal"];	
			}
            else{
			//TODO:
			/*EFFECT_KILL*/	
    //debugE("unhandled:"+getWeaponName(action["item"])+getChipName(action["item"]));
            }
        }
        //kill?
        // ici maybe check if damage pas < à 0 !
		//TODO dans le kill et le normal, faire les revoies de dégâts !
        if(virtualTargetState["life"]<=minDmgValue){
			minDmgValue=virtualTargetState["life"];
            score+=minDmgValue*_COEF_DMG[target];
            stackOfDeath[target]=target;
			score+=_SCORE_KILL_DMG*_COEF_DMG[target];
            //lifesteal
            lifeSteal+=minDmgValue*myWis/1000;
            if(lifeSteal>0){
                if(lifeSteal>lifeMissing)lifeSteal=lifeMissing;
                lifeMissing-=lifeSteal;
                score+=lifeSteal*_COEF_HEAL[_SELF]*_COEF_URGENT[_SELF];
				if(stackOfResult[_SELF]==null)stackOfResult[_SELF]=[];
                stackOfResult[_SELF]["heal"]+=lifeSteal;
            }
            //lifestealend
        }else if(virtualTargetState["psnlife"]-minDmgValue <= turnPsn){
			// kill poison, pas encore sur de comment je gère ça mieux...
            stackOfDeath[target]=target;
            score+=turnPsn*_COEF_DMG[target];
			score+=_SCORE_KILL_PSN*_COEF_DMG[target];
        }else{
            if(stackOfResult[target]==null)stackOfResult[target]=[];
            if(avgDmgValue){
                stackOfResult[target]["dmg"]+=minDmgValue; // sauvegarde du min
                score +=avgDmgValue*_COEF_DMG[target]; // score de l'avg
                //lifesteal
                lifeSteal+=avgDmgValue*myWis/1000;
                if(lifeSteal){
                    if(lifeSteal>lifeMissing)lifeSteal=lifeMissing;
                    lifeMissing-=lifeSteal;
                    score+=lifeSteal*_COEF_HEAL[_SELF]*_COEF_URGENT[_SELF];
					if(stackOfResult[_SELF]==null)stackOfResult[_SELF]=[];
                    stackOfResult[_SELF]["heal"]+=lifeSteal;
                }
                //lifestealend
            }
            if(avgPsn){
                stackOfResult[target]["psn"]+=turnPsn;
                score +=avgPsn*_COEF_DMG[target];
            }
            if(healValue){
				if(item==CHIP_VACCINE){
					var onEffect = _LEEKS[target]["effects"][item];
					if(onEffect != null) score+=onEffect*_COEF_HEAL[target];
					score -=healValue*_COEF_HEAL[target];
				}else{
					var totallife = virtualTargetState["totallife"];
					var targetMissingLife = totallife-virtualTargetState["life"];
					if(item==CHIP_REGENERATION){
						if(targetMissingLife >= healValue*0.8){
							if(healValue>targetMissingLife) healValue=targetMissingLife;
							stackOfResult[target]["heal"]+=healValue;
							score -=healValue*_COEF_HEAL[target]*_COEF_URGENT[target];
						}else{
							score -=200;
						}
					}else{
						if(healValue>targetMissingLife) healValue=targetMissingLife;
						stackOfResult[target]["heal"]+=healValue;
						score -=healValue*_COEF_HEAL[target]*_COEF_URGENT[target];
					}
				}
            }
			if(maxhpValue){
				score += maxhpValue*3; // TODO coef maxhp
			}
			if(absShieldValue){
				var onEffect = _LEEKS[target]["effects"][item];
				if(onEffect != null) score+=onEffect*_COEF_ABSSHIELD[target];
				else stackOfResult[target]["absShield"]+=absShieldValue;
				score -=absShieldValue*_COEF_ABSSHIELD[target];
				if(!_SCN_STR_100) score = 1;// todo del this & handle in coef.
			}
			if(relShieldValue){
				var onEffect = _LEEKS[target]["effects"][item];
				if(onEffect != null) score+=onEffect*4*_COEF_RELSHIELD[target];
				else stackOfResult[target]["relShield"]+=relShieldValue;
				score -=relShieldValue*4*_COEF_RELSHIELD[target];
				//*3 pour que 30% d'armure soit == à 120 armor abs environ
				// je pense que ce c'est discutable, selon les dégâts potentiels de l'adversaire, ptete faire un calcul en début de tour du "potentiel agressif" de la team en face en terme de force/science/magie pour orienter les choix ?
				if(!_SCN_STR_200) score = 1;
			}
			if(boostStrValue){
				var onEffect = _LEEKS[target]["effects"][item];
				if(onEffect != null) score+=onEffect*_COEF_STR_BOOST[target];
				else stackOfResult[target]["str"]+=boostStrValue;
				score -= boostStrValue*_COEF_STR_BOOST[target];
			}
			if(boostAgiValue){
				var onEffect = _LEEKS[target]["effects"][item];
				if(onEffect != null) score+=onEffect*_COEF_AGI_BOOST[target];
				score -= boostAgiValue*_COEF_AGI_BOOST[target];
			}
			if(boostMPValue){
				var onEffect = _LEEKS[target]["effects"][item];
				if(onEffect != null) score+=onEffect*40*_COEF_MP_BOOST[target];
				score -= boostMPValue*30*_COEF_MP_BOOST[target];//1mp=30str
			}
			if(boostTPValue){
				var onEffect = _LEEKS[target]["effects"][item];
				if(onEffect != null) score+=onEffect*40*_COEF_TP_BOOST[target];
				score -= boostTPValue*30*_COEF_TP_BOOST[target];//1tp=30str
			}
			if(shackleTPValue){
				score += shackleTPValue*30*_COEF_SHACKLE_TP[target];//30 en shackle aussi
			}
			if(shackleMPValue){
				score += shackleMPValue*30*_COEF_SHACKLE_MP[target];//30 en shackle
				stackOfResult[target]["shackleMP"]+=shackleMPValue;
			}
			if(shackleStrValue){
				score += shackleStrValue*_COEF_SHACKLE_STR[target];
			}
			if(shackleMgcValue){
				score += shackleMgcValue*_COEF_SHACKLE_MGC[target];
			}
			if(debuffValue){
				if(!isSummon(target)){
					stackOfResult[target]["debuff"]=true;
					score += debuffValue;
				}else{
					score -= 200;
				}
			}
			if(antidoteValue){
				stackOfResult[target]["antidote"]=true;
				score -= antidoteValue*_COEF_HEAL[target]*_COEF_URGENT[target];
			}
        }
    }
    return @score;
}

function addActionToMAPS(@item, @from, @to, @targets){
	var dist = reachableCells[from];
    if(dist==null)return; // filtering all action I can't reach
	if(assoc_weap_from[item]==null) assoc_weap_from[item] = [];
	push(assoc_weap_from[item], from);
	
	if(assoc_from_item_actions[from]==null) assoc_from_item_actions[from] = [];
	if(assoc_from_item_actions[from][item]==null) assoc_from_item_actions[from][item] = [];
	
	var action = ["item":item, "from":from, "to":to, "targets":targets];
	push(assoc_from_item_actions[from][item], action);
}

function setMapActions(){
	updateCoef();
	self_action_array = []; // clear
	assoc_weap_from = []; // clear
	assoc_from_item_actions = [];//clear
    var self = getLeek(), interest;
    for(var w in getWeapons()){
        var weaponArea = _ITEM_AREA[w];    
        if(weaponArea == AREA_POINT){ // normal cible unique.
            for(var target in getAliveEnemies()){ // pas d'ally susceptible d'être une cible.
                var toCell = getCell(target);
                var targets = [target];
                for(var from in _getCellsToUseWeapChipOnCell(w, toCell)){
                    addActionToMAPS(w, from, toCell, targets);
                }
            }
        }else if(weaponArea == AREA_LASER_LINE){ // cas d'un lazer
			var minrange = _ITEM_MINRANGE[w];
	        var maxrange = _ITEM_MAXRANGE[w];
            for(var fromCell = 0; fromCell < 613; fromCell++){
                if(_OBSTACLES[fromCell]==null){
                    for(var toCell in getLazerTargetsCell(fromCell, minrange)){
                        var targets = getLazerTargetsFromCell(fromCell, toCell, minrange, maxrange);
                        if(count(targets)>0){// ici du coup je rend le b_lazer useless
                            interest=0; // du fait de la simplification du test
                            for(var t in targets) interest+=_COEF_DMG[t];
                            if(interest>0) addActionToMAPS(w, fromCell, toCell, targets);
                        }
                    }
                }
            }
        }else{// cas des aoe AREA_CIRCLE_X (1, 2, 3)
        // TODO maybe opti en faisant qu'une fois les calcs par area pour weapon & chip
            for(var i = 0; i < 613; i++){
                if(_OBSTACLES[i]==null){
                    var targets = getWeaponTargets(w, i);
                    if(count(targets)>0){
                        interest=0;
                        for(var t in targets)
                            interest+=_COEF_DMG[t]*getDamagePercentage(i, getCell(t), weaponArea)/100;
                        if(interest>0) for(var from in _getCellsToUseWeapChipOnCell(w, i)){
                            addActionToMAPS(w, from, i, targets);
                        }
                    }
                }
            }
        }
    }// end for weapons
    for(var c in getChips()){
        if(getCooldown(c)!=0 || isSpecialChip(c)) continue;
        // pour le moment on gère pas les special chip
        var chipArea = _ITEM_AREA[c];
        // cannot be lazer_line
        if(chipArea==AREA_POINT){
            var targets = isPositivChip(c) ? getAliveAllies() : getAliveEnemies();
			for(var target in targets){
				// self_actions !
                if(target==_SELF && _ITEM_MINRANGE[c]==0 && self_action_array[c]==null){
					self_action_array[c] = c;
				}else if(target!=_SELF){	// others.
					var toCell = getCell(target);
					for(var from in _getCellsToUseWeapChipOnCell(c, toCell)){
						addActionToMAPS(c, from, toCell, [target]);
					}
				}
            }
        }else if(chipArea==AREA_LASER_LINE){
            debugE("CHIP LAZERLINE ?!?");
        }else{// cas des aoe AREA_CIRCLE_X (1, 2, 3)
        // TODO maybe opti en faisant qu'une fois les calcs par area pour weapon & chip
            var isPositiv = isPositivChip(c);
            for(var i = 0; i < 613; i++){
                if(_OBSTACLES[i]==null){
                    var targets = getChipTargets(c, i);
                    if(count(targets)>0){
                        interest=0;
                        for(var t in targets){
						// FIXME DMG ???? est-ce que je prend pas en fonction de l'effet de la puce ? mais ça va couté un bras ?
                            if(isPositiv)interest -= _COEF_DMG[t]* getDamagePercentage(i, getCell(t), chipArea)/100;
                            else interest += _COEF_DMG[t]* getDamagePercentage(i, getCell(t), chipArea)/100;
                        }
                        if(interest>0) for(var from in _getCellsToUseWeapChipOnCell(c, i)){
                            addActionToMAPS(c, from, i, targets);
                        }
                    }
                }
            }
        }
    }//end for chips
}

function findBestMove(@allCombos, @gravityArray){
	//raz du cache.
	_CACHE_SCORE_SAFECELL = [];
	var _BESTMOVE=null;
	var selfCell = getCell();
	var selfMP = getMP();
	var selfLife = getLife();
	var lifePercent = selfLife/getTotalLife();
	var ratioRisk = 100 + getLevel()*2;
	var cntCombo = count(allCombos);
	
	var __DEBUG_STRINGINFO = "";
	
	for(var combo in allCombos){
		cntCombo--;
		var fromArray = [];
		// find cells where every part of combo can be done.
		if(count(combo)==0){ // special case empty combo for safe play.
			push(fromArray, getCell());
		}else{	
			for(var c:var d in reachableCells){
				if(_OBSTACLES[c]!=null) continue;
				var ok = true, isOnlySelf = true;
				for(var item in combo){
					if(assoc_from_item_actions[c][item]==null){
						if(self_action_array[item]==null){
							ok = false;
							break;
						}
					}else{
						isOnlySelf = false;
					}
				}
				if(ok){
					if(isOnlySelf){ if(c==selfCell) { push(fromArray, c); }
					}else{ push(fromArray, c); }
				}
			}
		}
		// DEBUG
		for(var item in combo) __DEBUG_STRINGINFO += "-" + _ITEMID_TOSTRING[item];
		__DEBUG_STRINGINFO += ": " + count(fromArray) + "\n";
		// END DEBUG
		for(var aCell in fromArray){
			var mpMove1 = reachableCells[aCell];
			var mpLeft = selfMP - mpMove1;
			if(mpMove1 != null && mpLeft >= 0){
				var score = 0, tmpScore = 0, best = [], total;
				var stack = [], dead = [];
				// calcul du score de la meilleure combo depuis cette case.
				for(var item in combo){
					// meilleure score pour chaque item
					var actions = @assoc_from_item_actions[aCell][item];
					var aScore = 0, aBest, aStack, aDead;
					if(actions!=null){
						for(var action in actions){
							var tmpstack=stack, tmpdead=dead;
							tmpScore=getScoreOfAction(action, tmpstack, tmpdead);
							if(aBest == null || aScore < tmpScore){
								aScore = tmpScore;
								aBest = action;
								aStack = tmpstack;
								aDead = tmpdead;
							}
						}
					}//si actions est null, alors self_action ne peut pas être null.
					if(self_action_array[item]!=null){
						var tmpstack=stack, tmpdead=dead;
						//creation d'une action self sur cette case.
						var action = ["item":item, 
						"from":aCell, "to":aCell,
						"targets":[_SELF]];
						tmpScore=getScoreOfAction(action, tmpstack, tmpdead);
						if(aBest == null || aScore < tmpScore){
							aScore = tmpScore;
							aBest = action;
							aStack = tmpstack;
							aDead = tmpdead;
						}
					}
					if(aBest != null && aScore>0){
						aBest["score"] = aScore; // pour le debug
						push(best, aBest);
						stack = aStack;
						dead = aDead;
						score += aScore;
					}else{
						//l'action n'a pas été push car inutile, les TP restant sont libre pour lancer un buff
						//mayeb faire autrement, je laisse le commentaire ici.
					}
				}
				// à partir du score de la meilleure combo depuis aCell, recherche de la meilleure case safe.
				var uniqId = getUniqueID_safeCell(aCell, dead);
				if(_CACHE_SCORE_SAFECELL[uniqId]==null){
					var ignored = [selfCell];
					for(var d in dead) push(ignored, getCell(d));
					var reachable = getReachableCells([aCell:0], mpLeft, ignored);
					var result = getBestSafeCellScore(reachable, dead, selfLife, lifePercent, gravityArray);
					_CACHE_SCORE_SAFECELL[uniqId] = result;
				}
				var bestSafeMove = @_CACHE_SCORE_SAFECELL[uniqId];
				var safestCell = bestSafeMove["sCell"];
				var safeScore = bestSafeMove["score"];
				var minDanger = bestSafeMove["danger"];
				
				var finalScore = score + safeScore; // cumul des actions

				if(_BESTMOVE==null || _BESTMOVE["score"]<finalScore) _BESTMOVE = [
					"score":finalScore,
					"actions":best,
					//"aCell":aCell,
					"sCell":safestCell,
					"danger":minDanger,
					"stack":stack,//pour le debuging
					"dead":dead//pour le debuging
				];
				if(getOperations()>OPERATIONS_LIMIT*0.99){
					debugE("breaked ! Combos left: "+ cntCombo +"/"+count(allCombos));
					// DEBUG
					debug(__DEBUG_STRINGINFO);
					// END DEBUG
					return @_BESTMOVE;
				}
			}
		}
	}
	// DEBUG
	debug(__DEBUG_STRINGINFO);
	// END DEBUG
	return @_BESTMOVE;
}

// todo un jour, stocker les résult de getCellDanger selon les params pour pas refaire le calcule
function getBestSafeCellScore(@reachable, @dead, @selfLife, @lifePercent, @gravityArray){
	var minDanger = 9999999;
	var bestScore = -9999999;
	var safestCell;
	for(var sCell:var mpused in reachable){
		var danger = getCellDanger(sCell, dead);
		var tmpScore = 0;
		if(danger > selfLife*_RATIO_IGNORE_DANGER) tmpScore-= danger*_RATIO_DANGER;
		if(lifePercent<0.6) tmpScore*=2;
		if(danger >= selfLife) tmpScore-=_SCORE_DEATH;
		for(var cell:var dist in gravityArray){
			tmpScore -= abs(dist-getCellDistance(cell, sCell));
		}
		if(safestCell==null || tmpScore > bestScore){
			safestCell = sCell;
			minDanger = danger;
			bestScore = tmpScore;
		}
	}
	return @["sCell":safestCell, "danger":minDanger, "score":bestScore];
}

function playBestMove(bestMove){
	//moveTowardCell(bestMove["aCell"]);
	for(var action in bestMove["actions"]){
		debug(_ITEMID_TOSTRING[action["item"]]+": "+action["score"]);
		var item = action["item"], from = action["from"], to = action["to"];
		moveTowardCell(from);
		if(_ITEM_ISWEAP[item]){
			if(getWeapon()!=item) setWeapon(item);
			useWeaponOnCell(to);
		}
		else useChipOnCell(item, to);
		
		// on compte les utilisations :
		if(getLevel()>=32){
			var reg = getRegister(_ITEMID_TOSTRING[item]);
			if(reg==null)setRegister(_ITEMID_TOSTRING[item],1);
			else setRegister(_ITEMID_TOSTRING[item],number(reg)+1);
		}
	}
	moveTowardCell(bestMove["sCell"]);
}
