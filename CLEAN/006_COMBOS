include('auto');

//debut de chaque tour après avoir init la map de danger
function updateCoef(idbulb){
	var somme_life_ally = 0;
	var somme_life_enemy= 0;
	var count_ally = 0;
	var count_enemy= 0;
	var targets = _ALIVE_ALLIES+_ALIVE_ENEMIES;
	if(idbulb!=null) targets = [idbulb];
	else{
		_COEF_DMG = [];
		_COEF_HEAL = [];
		_COEF_VACCIN = [];
		_COEF_MAXHP_BOOST = [];
		_COEF_ABSSHIELD = [];
		_COEF_RELSHIELD = [];
		_COEF_STR_BOOST = [];
		_COEF_MP_BOOST = [];
		_COEF_TP_BOOST = [];	
		_COEF_AGI_BOOST = [];
		_COEF_WSD_BOOST = [];
		_COEF_RST_BOOST = [];
		_COEF_SHACKLE_TP = [];
		_COEF_SHACKLE_MP = [];
		_COEF_SHACKLE_STR = [];
		_COEF_SHACKLE_MGC = [];
		_COEF_LIBERATE = [];
		_COEF_RETURN_DMG = [];
	}
	for(var target in targets){
		if(__DDD_ON && getFightContext()==FIGHT_CONTEXT_CHALLENGE){
			_COEF_DMG[target]= randInt(-10, 11);
			_COEF_HEAL[target]= randInt(-10, 11);
			_COEF_VACCIN[target]= randInt(-10, 11);
			_COEF_MAXHP_BOOST[target]= randInt(-10, 11);
			_COEF_ABSSHIELD[target]= randInt(-10, 11);
			_COEF_RELSHIELD[target]= randInt(-10, 11);
			_COEF_STR_BOOST[target]= randInt(-10, 11);
			_COEF_MP_BOOST[target]= randInt(-10, 11);
			_COEF_TP_BOOST[target]= randInt(-10, 11);
			_COEF_AGI_BOOST[target]= randInt(-10, 11);
			_COEF_WSD_BOOST[target]= randInt(-10, 11);
			_COEF_RST_BOOST[target]= randInt(-10, 11);
			_COEF_SHACKLE_TP[target]= randInt(-10, 11);
			_COEF_SHACKLE_MP[target]= randInt(-10, 11);
			_COEF_SHACKLE_STR[target]= randInt(-10, 11);
			_COEF_SHACKLE_MGC[target]= randInt(-10, 11);
			_COEF_LIBERATE[target]= randInt(-10, 11);
			_COEF_RETURN_DMG[target]= randInt(-10, 11);
			continue;
		}
		var infos = _LEEKS[target];
		var eType = getEntityType(target);
		var lifeRatio = getLife(target)/getTotalLife(target);
		if(isAlly(target)){
			if(eType==ENTITY_LEEK_){
				var ignoreleeks=getListOfEnemyLeekWhoPlayAfter(target);
				var danger = getCellDanger(getCell(target), ignoreleeks, _EMPTYARRAY)[_danger];
				var canDie = (target != _SELF) && getLife(target) < danger*0.9;
				if(canDie) debugE("canDie: " + getName(target) + ":" + danger);
				somme_life_ally+=infos[_life]; // SUM LIFE ALLY
				count_ally++; // COUNT ALLY LEEK
				_COEF_HEAL[target] = -3;
				if(lifeRatio<0.9) _COEF_HEAL[target]+= -1;
				if(lifeRatio<0.7) _COEF_HEAL[target]+= -1;
				if(lifeRatio<0.5) _COEF_HEAL[target]+= -2;
				if(canDie) _COEF_HEAL[target]=-30; // !!!!!!!!!!!!!!!!!!
				else if(target==_SELF)_COEF_HEAL[target]+= -0.5;
				if(getLevel(target)<getLevel()/2) _COEF_HEAL[target]/=2;
				// reminder: doit être positif sinon les moins s'annulent !
				_COEF_DMG[target] = _COEF_HEAL[target];
				_COEF_VACCIN[target] = -2;
				if(lifeRatio<0.95 && !canDie) _COEF_VACCIN[target]+= -3;
				if(getLevel(target)<getLevel()/2) _COEF_VACCIN[target]/=2;
				_COEF_MAXHP_BOOST[target] = -3;
				if(getTotalLife(target)<=2400)_COEF_MAXHP_BOOST[target]+= -1;
				if(getTotalLife(target)<=2200)_COEF_MAXHP_BOOST[target]+= -1;
				if(getTotalLife(target)<=2000)_COEF_MAXHP_BOOST[target]+= -1;
				if(getTotalLife(target)<=1800)_COEF_MAXHP_BOOST[target]+= -2;
				if(getTotalLife(target)<=1600)_COEF_MAXHP_BOOST[target]+= -2;
				if(getTotalLife(target)<=1200)_COEF_MAXHP_BOOST[target]+= -3;
				if(getTotalLife(target)<=800)_COEF_MAXHP_BOOST[target]+= -3;
				if(target==_SELF && _IS_CAC)_COEF_MAXHP_BOOST[target]+= -3;
				_COEF_ABSSHIELD[target] = -1.5;
				if(infos[_absShield]==0) _COEF_ABSSHIELD[target]+= -2;
				if(lifeRatio<0.9)_COEF_ABSSHIELD[target]+= -0.2;
				if(lifeRatio<0.8)_COEF_ABSSHIELD[target]+= -0.2;
				if(lifeRatio<0.7)_COEF_ABSSHIELD[target]+= -0.2;
				if(lifeRatio<0.6)_COEF_ABSSHIELD[target]+= -0.2;
				if(lifeRatio<0.5)_COEF_ABSSHIELD[target]+= -0.2;
				if(lifeRatio<0.4)_COEF_ABSSHIELD[target]+= -0.2;
				if(lifeRatio<0.3)_COEF_ABSSHIELD[target]+= -0.2;
				if(lifeRatio<0.2)_COEF_ABSSHIELD[target]+= -0.2;
				if(canDie) _COEF_ABSSHIELD[target]=-30; // !!!!!!!!!!!!!!!!!!
				else if(target==_SELF && _IS_CAC)_COEF_ABSSHIELD[target]+= -0.5;
				else if(getScience(target)>500)_COEF_ABSSHIELD[target]+= -1;
				_COEF_RELSHIELD[target] = -1.5;
				if(infos[_relShield]==0) _COEF_RELSHIELD[target] += -2;
				if(lifeRatio<0.9)_COEF_RELSHIELD[target]+= -0.2;
				if(lifeRatio<0.8)_COEF_RELSHIELD[target]+= -0.2;
				if(lifeRatio<0.7)_COEF_RELSHIELD[target]+= -0.2;
				if(lifeRatio<0.6)_COEF_RELSHIELD[target]+= -0.2;
				if(lifeRatio<0.5)_COEF_RELSHIELD[target]+= -0.2;
				if(lifeRatio<0.4)_COEF_RELSHIELD[target]+= -0.2;
				if(lifeRatio<0.3)_COEF_RELSHIELD[target]+= -0.2;
				if(lifeRatio<0.2)_COEF_RELSHIELD[target]+= -0.2;
				if(canDie) _COEF_RELSHIELD[target]=-30; // !!!!!!!!!!!!!!!!!!
				else if(target==_SELF && _IS_CAC)_COEF_RELSHIELD[target]+= -0.5;
				else if(getScience(target)>500)_COEF_RELSHIELD[target]+= -1;
				_COEF_STR_BOOST[target] = -(getStrength(target)*2/1000);
				if(getStrength(target)>200) _COEF_STR_BOOST[target] += -3;
				if(target!=_SELF && getStrength(target)>0) _COEF_STR_BOOST[target] += -0.1;
				_COEF_MP_BOOST[target] = -2.7;
				if(getMP(target)<9) _COEF_MP_BOOST[target]+= -0.2;
				if(target==_SELF&&count(_ALIVE_ALLIES_LEEKS)>1) _COEF_MP_BOOST[target]+= 1;
				_COEF_TP_BOOST[target] = -2.7;
				_COEF_AGI_BOOST[target] = -2;
				_COEF_WSD_BOOST[target] = -2;
				_COEF_RST_BOOST[target] = -(getResistance(target)/100);
				_COEF_SHACKLE_TP[target] = -2;
				_COEF_SHACKLE_MP[target] = -2;
				_COEF_SHACKLE_STR[target] = -2;
				_COEF_SHACKLE_MGC[target] = -2;
				_COEF_LIBERATE[target] = -1;
				_COEF_RETURN_DMG[target] = -3;
			}
			else {//bulb
				count_ally+=0.4;
				somme_life_ally+=infos[_life]*0.4; // ???
				_COEF_HEAL[target] = -2;
				if(lifeRatio<0.8) _COEF_HEAL[target]+= -0.75;
				if(lifeRatio<0.6) _COEF_HEAL[target]+= -0.75;
				if(lifeRatio<0.4) _COEF_HEAL[target]+= -0.75;
				_COEF_DMG[target] = _COEF_HEAL[target];
				if(lifeRatio==1) _COEF_VACCIN[target]=0;
				else{
					_COEF_VACCIN[target] = -0.75;
					if(lifeRatio<0.9 && lifeRatio>0.5) _COEF_VACCIN[target]+= -0.5;
				}
				if(eType==ENTITY_METALLIC_BULB){
					_COEF_HEAL[target]/=2;
					_COEF_VACCIN[target]/=2;
				}
				_COEF_MAXHP_BOOST[target] = -2.9;
				if(getTotalLife(target)>800) _COEF_MAXHP_BOOST[target] += 0.5;
				if(getTotalLife(target)>1400) _COEF_MAXHP_BOOST[target] += 0.5;
				if(getTotalLife(target)>2000) _COEF_MAXHP_BOOST[target] += 0.5;
				if(eType==ENTITY_METALLIC_BULB && getTotalLife(target)>1500) _COEF_MAXHP_BOOST[target] += 0.5;
				_COEF_ABSSHIELD[target] = -1.2;
				if(eType==ENTITY_METALLIC_BULB) _COEF_ABSSHIELD[target] = -0.1;
				_COEF_RELSHIELD[target] = -1.2;
				if(eType==ENTITY_METALLIC_BULB) _COEF_RELSHIELD[target] = -0.1;
				_COEF_STR_BOOST[target] = -2;
				if(eType==ENTITY_HEALER_BULB) _COEF_STR_BOOST[target] = 0;
				if(eType==ENTITY_METALLIC_BULB) _COEF_STR_BOOST[target] = 0;
				_COEF_MP_BOOST[target] = -1;
				if(getStrength(target)>=300) _COEF_MP_BOOST[target]+= -2;
				if(getStrength(target)>=600) _COEF_MP_BOOST[target]+= -2;
				_COEF_TP_BOOST[target] = -1;
				if(round(rand()))_COEF_TP_BOOST[target] += -0.1;
				if(getStrength(target)>=300) _COEF_TP_BOOST[target]+= -2;
				if(getStrength(target)>=600) _COEF_TP_BOOST[target]+= -2;
				_COEF_AGI_BOOST[target] = -1;
				_COEF_WSD_BOOST[target] = -1;
				_COEF_RST_BOOST[target] = -(getResistance(target)/200);
				_COEF_SHACKLE_TP[target] = -1;
				_COEF_SHACKLE_MP[target] = -1;
				_COEF_SHACKLE_STR[target] = -1;
				_COEF_SHACKLE_MGC[target] = -1;
				_COEF_LIBERATE[target] = -0.5;
				_COEF_RETURN_DMG[target] = -2;
			}
		}else{//enemy
			_COEF_VACCIN[target] = 2;
			_COEF_MAXHP_BOOST[target] = 2;
			_COEF_ABSSHIELD[target] = 2;
			_COEF_RELSHIELD[target] = 2;
			_COEF_STR_BOOST[target] = 2;
			_COEF_MP_BOOST[target] = 2;
			_COEF_TP_BOOST[target] = 2;
			_COEF_AGI_BOOST[target] = 2;
			_COEF_WSD_BOOST[target] = 2;
			_COEF_RST_BOOST[target] = 2;
			_COEF_RETURN_DMG[target] = 2;
			if(eType==ENTITY_LEEK_){
				somme_life_enemy+=infos[_life]; // SUM LIFE ENEMY
				count_enemy++; // COUNT ENEMY LEEK
				_COEF_DMG[target] = 6;
				if(lifeRatio<0.8)_COEF_DMG[target]+= 1;
				if(getLevel(target)<getLevel()/2) _COEF_DMG[target] -= 1;
				_COEF_HEAL[target] = _COEF_DMG[target];
				_COEF_SHACKLE_TP[target] = 5;
				_COEF_SHACKLE_MP[target] = 5;
				_COEF_SHACKLE_STR[target] = 4;
				if(infos[_str]<100) _COEF_SHACKLE_STR[target] = 0.5;
				_COEF_SHACKLE_MGC[target] = 3;
				if(infos[_mgc]<100) _COEF_SHACKLE_MGC[target] = 0.5;
				_COEF_LIBERATE[target] = 1;
			}
			else{//bulb
				somme_life_enemy+=infos[_life]*0.5; // SUM LIFE ENEMY
				count_enemy+=0.5;// COUNT ENEMY BULB
				if(eType==ENTITY_PUNY_BULB) _COEF_DMG[target] = 1;
				else if(eType==ENTITY_METALLIC_BULB) _COEF_DMG[target] = 4.5;
				else _COEF_DMG[target] = 5;
				_COEF_HEAL[target] = _COEF_DMG[target];
				_COEF_SHACKLE_TP[target] = 0.25;
				_COEF_SHACKLE_MP[target] = 0.25;
				_COEF_SHACKLE_STR[target] = 1;
				if(eType==ENTITY_HEALER_BULB 
				|| eType==ENTITY_METALLIC_BULB) _COEF_SHACKLE_STR[target] = 0;
				_COEF_SHACKLE_MGC[target] = 0;
				_COEF_LIBERATE[target] = 0.5;
			}
		}
	}// end for(var target in targets)
	if(__DDD_ON && getFightContext()==FIGHT_CONTEXT_CHALLENGE){
		_RATIO_IGNORE_DANGER = rand();
		_RATIO_DANGER = rand();
		return;
	}
	if(idbulb==null){
		// fix des vals global
		var ratioPv = somme_life_ally/somme_life_enemy;
		if(ratioPv > 2) _RATIO_IGNORE_DANGER = 0.90;
		else if(ratioPv > 1.75) _RATIO_IGNORE_DANGER = 0.70;
		else if(ratioPv > 1.5) _RATIO_IGNORE_DANGER = 0.5;
		else if(ratioPv > 1.25) _RATIO_IGNORE_DANGER = 0.30;
		else _RATIO_IGNORE_DANGER = 0.10;
		
		if(getFightType()!= FIGHT_TYPE_SOLO && getScience()<400) _RATIO_IGNORE_DANGER+=0.2;
		else if(getFightType() == FIGHT_TYPE_SOLO) _RATIO_IGNORE_DANGER/=2;
		if(_RATIO_DANGER>=0.9) _RATIO_IGNORE_DANGER = 0.9;
		
		
		var ratioCount = count_ally/count_enemy;
		if(ratioCount > 2) _RATIO_DANGER = 1;
		else if(ratioCount > 1.6) _RATIO_DANGER = 2;
		else if(ratioCount > 1.3) _RATIO_DANGER = 3;
		else _RATIO_DANGER = 4;
		
		if(_CANT_HEAL){
			_RATIO_DANGER = 5;
			_RATIO_IGNORE_DANGER = 0;
		}
		if(_IS_CAC) _RATIO_DANGER/=2;
		// au cas ou je veux modif ça un jour...
		//_SCORE_KILL_DMG = 200;
		//_SCORE_KILL_PSN = 50;
		//_SCORE_DEATH = 1000;
	}
}
                 
// TODO liberate remove reduc.
function getVirtualState(@leek, @stackOfResult){
    var state = _LEEKS[leek];
	if(stackOfResult[leek]==null) return @state;
	if(stackOfResult[leek][_debuff]==true){
		state[_psnlife] = state[_life];
		state[_psnTurn] = 0;
		state[_psnTotal] = 0;
		state[_absShield] = 0;
		state[_relShield] = 0;
	}
	if(stackOfResult[leek][_antidote]==true){
		state[_psnlife] = state[_life];
		state[_psnTurn] = 0;
		state[_psnTotal] = 0;
	}
	state[_mp]-=stackOfResult[leek][_shackleMP];
	state[_absShield]+=stackOfResult[leek][_absShield];
	state[_relShield]+=stackOfResult[leek][_relShield];
	state[_str]+=stackOfResult[leek][_str];
	state[_rst]+=stackOfResult[leek][_rst];
    state[_life]-=stackOfResult[leek][_dmg];
    state[_life]+=stackOfResult[leek][_heal];
    if(state[_totallife]<state[_life])state[_life]=state[_totallife];
    state[_psnlife]-=stackOfResult[leek][_psn];
	state[_psnTurn]+=stackOfResult[leek][_psn];
    return @state;
}

function getSpecialChipScore(item){
	var score = 0;
	if(item==CHIP_RESURRECTION){
			score=_RESU_SCORE;
	}else if(count(_ALIVE_ALLIES_BULBS)>=6) return 0;
	else{
		var cost = _ITEM_COST[item];
		if(item==CHIP_FIRE_BULB){
			cost+=2;//avoid only summoning lightning.
			score -=1;//but prefer lightning over firebulb
		}else if(item==CHIP_HEALER_BULB && getLife()<getTotalLife()){
			cost+=1;
		}
		if(_COUNT_FIRE+_COUNT_LIGHTNING==0 && (item==CHIP_FIRE_BULB || item==CHIP_LIGHTNING_BULB)){
			cost+=9; //bonus summon d'un bulb offensif quand y'en a pas.
		}else if(_COUNT_ICED==0 && item==CHIP_ICED_BULB){
			cost+=4;
		}else if(_COUNT_ROCKY==0 && item==CHIP_ROCKY_BULB){
			cost+=3;
		}else if(count(_ALIVE_ALLIES_BULBS)-_COUNT_HEALER-_COUNT_METAL<=2){
			cost+=2;
		} 
		score += cost*(150-(count(_ALIVE_ALLIES_BULBS)*4)); // TODO ???
		if(_COUNT_HEALER>=2 && item == CHIP_HEALER_BULB) score/=5;
		if(_COUNT_METAL>=1 && item == CHIP_METALLIC_BULB) score/=5;
	}
	return score;
}

function getScoreOfAction(@action, @stackOfResult, @stackOfDeath){
	//DEBUG
	startBenchFunction("getScoreOfAction");
	//DEBUG
	var cacheThis = false;
	// gestion du cache
	var uniqId = ""+action+stackOfResult+stackOfDeath;
	if(_CACHE_SCORE_ACTION[uniqId] != null){
		stackOfResult = _CACHE_SCORE_ACTION[uniqId][_stackOfResult];
		stackOfDeath = _CACHE_SCORE_ACTION[uniqId][_stackOfDeath];
		stopBenchFunction("getScoreOfAction");
		return _CACHE_SCORE_ACTION[uniqId][_score];
	}else{
		cacheThis = true;
	}
	
    var me = getVirtualState(_SELF, stackOfResult),
	myStr = me[_str],
    myMgc = me[_mgc],
    myWis = me[_wsd],
	myRst = me[_rst],
	mySnc = me[_snc],
	myAgi = me[_agi],
	myAbsShield = me[_absShield],
	myRelShield = me[_relShield],
    item = action[_item],
    lifeMissing = me[_totallife]-me[_life],
    area = _ITEM_AREA[item],
    isAOE = area==AREA_CIRCLE_1||area==AREA_CIRCLE_2||area==AREA_CIRCLE_3,
    effects = @_ITEM_EFFECTS[item],
    score = 0,
	from = action[_from],
	to = action[_to],
	isSelf = from==to;
	// gestion inaoe
 	if((item == CHIP_DRIP && getCellDistance(from, to)<=2) || item == CHIP_DEVIL_STRIKE){
		if(!inArray(action[_targets], _SELF)) push(action[_targets], _SELF);
		isSelf=true;
	}
	// gestion summon
	if(isSpecialChip(item)){
		score = getSpecialChipScore(item);
	}
	else for(var target in action[_targets]){
        if(target==_SELF && !isSelf) continue; // ignore self, je suis pas sur la case ici !
        if(stackOfDeath[target]!=null) continue; // si la cible est déjà morte, next !
        var virtualTargetState = getVirtualState(target, stackOfResult);
		var targetCell;
		if(target==_SELF) targetCell = from;
		else targetCell = getCell(target);
        var dmgRatio = isAOE? getDamagePercentage(targetCell, to, area) : 100;

        var minDmgValue=0, avgDmgValue=0, turnPsn=0, avgPsn=0, healValue=0, maxhpValue=0, absShieldValue=0, relShieldValue=0, boostStrValue=0, boostAgiValue=0, boostResValue=0, boostTPValue=0, boostMPValue=0, lifeSteal=0, shackleTPValue=0, shackleMPValue=0, shackleStrValue=0, shackleMgcValue=0, debuffValue=0, antidoteValue=0, returnDmgValue=0;
		var duration;
        for(var e in effects){
			var type = e[0];
			var min = e[1];
			var max = e[2];
			var moy = (min+max)/2;
			var optimistmoy = (max+moy)/2;
			var pessimistmoy = (min+moy)/2;
			duration = e[3];
			duration = duration == 0 ? 1 : // 0 => 1
				(duration == 2 ? 1.5 : // 2 => 1.5
				(duration == 3 ? 2 : // 3 => 2
				(duration == 4 ? 2.5 : // 4 => 2.5
				duration))); // 1 => 1
            if(type == EFFECT_DAMAGE){
                minDmgValue += ( pessimistmoy*(1+(myStr/100))
                    *(1-(virtualTargetState[_relShield]/100))
                    *(dmgRatio/100)) - virtualTargetState[_absShield];
                avgDmgValue += (optimistmoy*(1+(myStr/100))
                    *(1-(virtualTargetState[_relShield]/100))
                    *(dmgRatio/100)) - virtualTargetState[_absShield];
				if(avgDmgValue<0) avgDmgValue = 0;
            }
            else if(type == EFFECT_POISON){
                turnPsn += pessimistmoy*(1+(myMgc/100))*(dmgRatio/100);
                avgPsn += moy*(1+(myMgc/100))*(dmgRatio/100) *duration;
            }
            else if(type == EFFECT_HEAL){
                healValue = moy*(1+(myWis/100))*(dmgRatio/100)*duration;
            }
			else if(type == EFFECT_BOOST_MAX_LIFE){
				maxhpValue = moy*(1+(myWis/100))*(dmgRatio/100);
			}
			else if(type == EFFECT_ABSOLUTE_SHIELD){
				absShieldValue = moy*(1+(myRst/100))*(dmgRatio/100)*duration;
			}
			else if(type == EFFECT_RELATIVE_SHIELD){
				relShieldValue = moy*(1+(myRst/100))*(dmgRatio/100)*duration;
			}
			else if(type == EFFECT_BUFF_STRENGTH){
				boostStrValue = moy*(1+(mySnc/100))*(dmgRatio/100)*duration;
			}
			else if(type == EFFECT_BUFF_AGILITY
			|| type == EFFECT_BUFF_WISDOM){
				boostAgiValue = moy*(1+(mySnc/100))*(dmgRatio/100)*duration;
				// un seul test pour la simplcité pour le moment.
			}
			else if(type == EFFECT_BUFF_RESISTANCE){
				boostResValue = moy*(1+(mySnc/100))*(dmgRatio/100)*duration;
			}
			else if(type == EFFECT_BUFF_MP){
				boostMPValue = round(moy*(1+(mySnc/100))*(dmgRatio/100))*duration;
			}
			else if(type == EFFECT_BUFF_TP){
				boostTPValue = round(moy*(1+(mySnc/100))*(dmgRatio/100))*duration;
			}
			else if(type == EFFECT_SHACKLE_TP){
				var mgcReduced = myMgc-virtualTargetState[_snc];
				mgcReduced = mgcReduced < 0 ? 0 : mgcReduced;
				shackleTPValue = round(pessimistmoy*(1+mgcReduced/100)*(dmgRatio/100))*duration;
			}
			else if(type == EFFECT_SHACKLE_MP){
				var mgcReduced = myMgc-virtualTargetState[_snc];
				mgcReduced = mgcReduced < 0 ? 0 : mgcReduced;
				shackleMPValue = round(pessimistmoy*(1+mgcReduced/100)*(dmgRatio/100))*duration;
			}
			else if(type == EFFECT_SHACKLE_STRENGTH){
				var mgcReduced = myMgc-virtualTargetState[_snc];
				mgcReduced = mgcReduced < 0 ? 0 : mgcReduced;
				shackleStrValue = round(moy*(1+mgcReduced/100)*(dmgRatio/100))*duration;
			}
			else if(type == EFFECT_SHACKLE_MAGIC){
				var mgcReduced = myMgc-virtualTargetState[_snc];
				mgcReduced = mgcReduced < 0 ? 0 : mgcReduced;
				shackleMgcValue = round(moy*(1+mgcReduced/100)*(dmgRatio/100))*duration;
			}
			else if(type == EFFECT_DEBUFF){ // LIBERATION !
				debuffValue = _LEEKS[target][_scoreLibe];
			}
			else if(type == EFFECT_ANTIDOTE){
				antidoteValue= virtualTargetState[_psnTotal];	
			}
			else if(type == EFFECT_KILL){
				if(isSummon(target)&&isAlly(target)){
					minDmgValue = getLife(target);
					avgDmgValue = minDmgValue;
				}
			}
			else if(type == EFFECT_DAMAGE_RETURN){
				returnDmgValue=moy*(1+(myAgi/100))*(dmgRatio/100)*duration;
			}
            else{
				debugE("unhandled:"+getWeaponName(action[_item])+getChipName(action[_item]));
            }
			
			//gestion libé
			if(target==_SELF){
				if(stackOfResult[_SELF]==null)stackOfResult[_SELF]=[];
				var val = absShieldValue > 0 ? absShieldValue : 
							relShieldValue > 0 ? relShieldValue :
							boostStrValue > 0 ? boostStrValue :
							boostAgiValue > 0 ? boostAgiValue :
							boostResValue > 0 ? boostResValue : 
							boostTPValue > 0 ? boostTPValue :
							boostMPValue > 0 ? boostMPValue :
							returnDmgValue > 0 ? returnDmgValue : 0;
				if(val > 0){
					stackOfResult[_SELF][_scoreLibe]+= getLibeScore(type, val, duration);
				}
			}
        }
        // ici maybe check if damage pas < à 0 !
		//TODO dans le kill et le normal, faire les revoies de dégâts !
        if(virtualTargetState[_life]<=minDmgValue){
			minDmgValue=virtualTargetState[_life];
            score+=minDmgValue*_COEF_DMG[target];
            stackOfDeath[target]=target;
			var isBulb = isSummon(target) ? 0.3 : 1;
			score+=_SCORE_KILL_DMG*_COEF_DMG[target]*isBulb;
			// mort de ses bulbes
			for(var bulb in virtualTargetState[_bulbs]){
				stackOfDeath[bulb]=bulb;
				score+=_SCORE_KILL_DMG*_COEF_DMG[bulb]*0.3;
			}
            //lifesteal
            lifeSteal+=minDmgValue*myWis/1000;
            if(lifeSteal>0 && target!=_SELF){
                if(lifeSteal>lifeMissing)lifeSteal=lifeMissing;
                lifeMissing-=lifeSteal;
                score+=lifeSteal*_COEF_HEAL[_SELF];
				if(stackOfResult[_SELF]==null)stackOfResult[_SELF]=[];
                stackOfResult[_SELF][_heal]+=lifeSteal;
            }
            //lifestealend
        }else if(turnPsn>0 && virtualTargetState[_psnlife] <= turnPsn){
			// kill poison, pas encore sur de comment je gère ça mieux...
            stackOfDeath[target]=target;
            score+=turnPsn*_COEF_DMG[target];
			score+=_SCORE_KILL_PSN*_COEF_DMG[target];
			// mort de ses bulbes
			for(var bulb in virtualTargetState[_bulbs]){
				stackOfDeath[bulb]=bulb;
				score+=_SCORE_KILL_PSN*_COEF_DMG[bulb];
			}
        }else{
            if(stackOfResult[target]==null)stackOfResult[target]=[];
            if(avgDmgValue){
                stackOfResult[target][_dmg]+=minDmgValue; // sauvegarde du min
                score +=avgDmgValue*_COEF_DMG[target]; // score de l'avg
                //lifesteal
                lifeSteal+=avgDmgValue*myWis/1000;
                if(lifeSteal>0 && target!=_SELF){
                    if(lifeSteal>lifeMissing)lifeSteal=lifeMissing;
                    lifeMissing-=lifeSteal;
                    score+=lifeSteal*_COEF_HEAL[_SELF];
					if(stackOfResult[_SELF]==null)stackOfResult[_SELF]=[];
                    stackOfResult[_SELF][_heal]+=lifeSteal;
                }
                //lifestealend
            }
            if(avgPsn){
                stackOfResult[target][_psn]+=turnPsn;
                var ratioBulb = isSummon(target) ? 0.5 : 1;
                score +=avgPsn*_COEF_DMG[target]*ratioBulb;
            }
            if(healValue){
				if(item==CHIP_VACCINE){
					var onEffect = _LEEKS[target][_effects][item];
					if(onEffect != null) score+=onEffect*_COEF_VACCIN[target];
					score -=healValue*_COEF_VACCIN[target];
				}else{
					var totallife = virtualTargetState[_totallife];
					var targetMissingLife = totallife-virtualTargetState[_life];
					if(item==CHIP_REGENERATION){
						if(targetMissingLife >= healValue*0.9){
							if(healValue>targetMissingLife) healValue=targetMissingLife;
							stackOfResult[target][_heal]+=healValue;
							score -=healValue*_COEF_HEAL[target];
							if(isSummon(target))score/=4;
						}else{
							score -=200;
						}
					}else{
						if(healValue>targetMissingLife) healValue=targetMissingLife;
						stackOfResult[target][_heal]+=healValue;
						score -=healValue*_COEF_HEAL[target];
					}
				}
            }
			if(maxhpValue){
				score -= maxhpValue*_COEF_MAXHP_BOOST[target];
			}
			if(absShieldValue){
				var alreadyHaveArmor = stackOfResult[target][_absShield] > 0;
				var onEffect = _LEEKS[target][_effects][item];
				if(onEffect != null) score+=onEffect*_COEF_ABSSHIELD[target];
				else stackOfResult[target][_absShield]+=absShieldValue/duration;
				score -=absShieldValue*_COEF_ABSSHIELD[target];
				if(alreadyHaveArmor) score/=2;
				if(!_SCN_STR_100) score = 1;// todo del this & handle in coef.
			}
			if(relShieldValue){
				var alreadyHaveArmor = stackOfResult[target][_relShield] > 0;
				var onEffect = _LEEKS[target][_effects][item];
				if(onEffect != null) score+=onEffect*4*_COEF_RELSHIELD[target];
				else stackOfResult[target][_relShield]+=relShieldValue/duration;
				score -=relShieldValue*_SCORE_REL_SHIELD*_COEF_RELSHIELD[target];
				if(alreadyHaveArmor) score/=2;
				//*3 pour que 30% d'armure soit == à 90 armor abs environ
				// je pense que ce c'est discutable, selon les dégâts potentiels de l'adversaire, ptete faire un calcul en début de tour du "potentiel agressif" de la team en face en terme de force/science/magie pour orienter les choix ?
				if(!_SCN_STR_200) score = 1;
			}
			if(boostStrValue){
				var onEffect = _LEEKS[target][_effects][item];
				if(onEffect != null) score+=onEffect*_COEF_STR_BOOST[target];
				else stackOfResult[target][_str]+=boostStrValue/duration;
				score -= boostStrValue*_COEF_STR_BOOST[target];
			}
			if(boostAgiValue){
				var onEffect = _LEEKS[target][_effects][item];
				if(onEffect != null) score+=onEffect*_COEF_AGI_BOOST[target];
				score -= boostAgiValue*_COEF_AGI_BOOST[target];
			}
			if(boostResValue){
				var onEffect = _LEEKS[target][_effects][item];
				if(onEffect != null) score+=onEffect*_COEF_RST_BOOST[target];
				else stackOfResult[target][_rst]+=boostResValue/duration;
				score -= boostResValue*_COEF_RST_BOOST[target];
			}
			if(boostMPValue){
				var onEffect = _LEEKS[target][_effects][item];
				if(onEffect != null) score+=onEffect*40*_COEF_MP_BOOST[target];
				else stackOfResult[target][_mp]+=boostMPValue/duration;
				score -= boostMPValue*_SCORE_MP*_COEF_MP_BOOST[target];//1mp=30str
			}
			if(boostTPValue){
				var onEffect = _LEEKS[target][_effects][item];
				if(onEffect != null) score+=onEffect*40*_COEF_TP_BOOST[target];
				score -= boostTPValue*_SCORE_TP*_COEF_TP_BOOST[target];//1tp=30str
			}
			if(shackleTPValue){
				score += shackleTPValue*_SCORE_TP*_COEF_SHACKLE_TP[target];
				stackOfResult[target][_shackleTP]+=shackleMgcValue/duration;
			}
			if(shackleMPValue && virtualTargetState[_mp]-stackOfResult[target][_shackleMP]>0){
				score += shackleMPValue*_SCORE_MP*_COEF_SHACKLE_MP[target];
				stackOfResult[target][_shackleMP]+=shackleMPValue/duration;
			}
			if(shackleStrValue){
				score += shackleStrValue*_COEF_SHACKLE_STR[target];
				stackOfResult[target][_shackleStr]+=shackleStrValue/duration;
			}
			if(shackleMgcValue){
				score += shackleMgcValue*_COEF_SHACKLE_MGC[target];
				stackOfResult[target][_shackleMgc]+=shackleMgcValue/duration;
			}
			if(debuffValue){
				stackOfResult[target][_debuff]=true;
				score += debuffValue*_COEF_LIBERATE[target];
			}
			if(antidoteValue){
				stackOfResult[target][_antidote]=true;
				score -= antidoteValue*_COEF_HEAL[target];
			}
			if(returnDmgValue){
				var onEffect = _LEEKS[target][_effects][item];
				if(onEffect != null) score+=onEffect*4*_COEF_RETURN_DMG[target];
				else stackOfResult[target][_relShield]+=returnDmgValue;
				score -=returnDmgValue*_SCORE_REL_SHIELD*_COEF_RETURN_DMG[target];
				if(!_SCN_STR_200) score = 1;
			}
        }
    }
	if(cacheThis){
		_CACHE_SCORE_ACTION[uniqId] = [];
		_CACHE_SCORE_ACTION[uniqId][_stackOfResult] = stackOfResult;
		_CACHE_SCORE_ACTION[uniqId][_stackOfDeath] = stackOfDeath;
		_CACHE_SCORE_ACTION[uniqId][_score] = score;
	}
	stopBenchFunction("getScoreOfAction");
    return @score;
}

function addActionToMAPS(@item, @from, @to, @targets){
	var dist = reachableCells[from];
    if(dist==null )return; // filtering all action I can't reach
	if(assoc_weap_from[item]==null) assoc_weap_from[item] = [];
	push(assoc_weap_from[item], from);
	
	if(assoc_from_item_actions[from]==null) assoc_from_item_actions[from] = [];
	if(assoc_from_item_actions[from][item]==null) assoc_from_item_actions[from][item] = [];
	
	var action = [_item:item, _from:from, _to:to, _targets:targets];
	push(assoc_from_item_actions[from][item], action);
}
function setMapActions(){
	prepareSetMapActions();
	self_action_array = []; // clear
	assoc_weap_from = []; // clear
	assoc_from_item_actions = [];//clear
    var interest;
    for(var w in getWeapons()){
        var weaponArea = _ITEM_AREA[w];    
        if(weaponArea == AREA_POINT){ // normal cible unique.
            for(var target in getAliveEnemies()){ // pas d'ally susceptible d'être une cible.
                var toCell = getCell(target);
                var targets = [target];
                for(var from in _getCellsToUseWeapChipOnCell(w, toCell)){
                    addActionToMAPS(w, from, toCell, targets);
                }
            }
        }else if(weaponArea == AREA_LASER_LINE){ // cas d'un lazer
			var minrange = _ITEM_MINRANGE[w];
	        var maxrange = _ITEM_MAXRANGE[w];			
			for(var leek in _ALIVE_ALLIES+_ALIVE_ENEMIES){
				if(leek==_SELF) continue;
				var toCell = getCell(leek);
				for(var from in getLazerFromCellsToTargetCell(toCell,minrange,maxrange)){
					var targets = getLazerTargetsFromCell(from, toCell, minrange, maxrange);
					if(count(targets)>0){
						interest=0;
						for(var t in targets) interest+=_COEF_DMG[t];
						if(interest>0) addActionToMAPS(w, from, toCell, targets);
						else if(interest<0 && w==WEAPON_B_LASER) addActionToMAPS(w, from, toCell, targets);
					}
				}
			}
        }else{// cas des aoe AREA_CIRCLE_X (1, 2, 3)
        	var cells;
			if(weaponArea==AREA_CIRCLE_1) cells = @atkCellsArea1;
			else if(weaponArea==AREA_CIRCLE_2) cells = @atkCellsArea2;
			else if(weaponArea==AREA_CIRCLE_3) cells = @atkCellsArea3;
            for(var i in cells){
                if(_OBSTACLES[i]==null){
                    var targets = getWeaponTargets(w, i);
                    if(count(targets)>0){
                        interest=0;
                        for(var t in targets)
                            interest+=_COEF_DMG[t]*getDamagePercentage(i, getCell(t), weaponArea)/100;
                        if(interest>0) for(var from in _getCellsToUseWeapChipOnCell(w, i)){
                            addActionToMAPS(w, from, i, targets);
                        }
                    }
                }
            }
        }
    }// end for weapons
    for(var c in getChips()){
        if(getCooldown(c)!=0) continue;
        // pour le moment on gère pas les special chip
        var chipArea = _ITEM_AREA[c];
        // cannot be lazer_line
        if(isSpecialChip(c)){
			// TODO handle resu, inversion & teleport..
			self_action_array[c] = c;
		}else if(chipArea==AREA_POINT){
            var targets;
			if(c==CHIP_LIBERATION){
				targets = _ALIVE_ALLIES+_ALIVE_ENEMIES;
			}else if(_CHIP_ISPOSITIV[c]){
				var isOnlyBulb = _CHIP_ISONLYBULB[c];
				if(isOnlyBulb) targets = _ALIVE_ALLIES_BULBS;
				else if(isOnlyBulb===null) targets = _ALIVE_ALLIES_LEEKS;
				else targets = _ALIVE_ALLIES;
			}else{
				targets = _ALIVE_ENEMIES;
			}
			for(var target in targets){
				// self_actions !
                if(target==_SELF && _ITEM_MINRANGE[c]==0 && self_action_array[c]==null){
					self_action_array[c] = c;
				}else if(target!=_SELF){	// others.
					var toCell = getCell(target);
					for(var from in _getCellsToUseWeapChipOnCell(c, toCell)){
						addActionToMAPS(c, from, toCell, [target]);
					}
				}
            }
        }else if(chipArea==AREA_LASER_LINE){
            debugE("CHIP LAZERLINE ?!?");
        }else{// cas des aoe AREA_CIRCLE_X (1, 2, 3)
        // TODO maybe opti en faisant qu'une fois les calcs par area pour weapon & chip
            var isPositiv = isPositivChip(c);
			var cells;
			if(isPositiv){
				if(chipArea==AREA_CIRCLE_1) cells = @defCellsArea1;
				else if(chipArea==AREA_CIRCLE_2) cells = @defCellsArea2;
				else if(chipArea==AREA_CIRCLE_3) cells = @defCellsArea3;
			}else{
				if(chipArea==AREA_CIRCLE_1) cells = @atkCellsArea1;
				else if(chipArea==AREA_CIRCLE_2) cells = @atkCellsArea2;
				else if(chipArea==AREA_CIRCLE_3) cells = @atkCellsArea3;
			}
            for(var i in cells){
                if(_OBSTACLES[i]==null){
                    var targets = getChipTargets(c, i);
                    if(count(targets)>0){
						interest=0;
                        for(var t in targets){
						// FIXME DMG ???? est-ce que je prend pas en fonction de l'effet de la puce ? mais ça va couté un bras ?
                            if(isPositiv)interest -= _COEF_DMG[t]* getDamagePercentage(i, getCell(t), chipArea)/100;
                            else interest += _COEF_DMG[t]* getDamagePercentage(i, getCell(t), chipArea)/100;
                        }
                        if(interest>0) for(var from in _getCellsToUseWeapChipOnCell(c, i)){
                            addActionToMAPS(c, from, i, targets);
                        }
                    }
                }
            }
        }
    }//end for chips
}

function findBestMove(@allComboz, @gravityArray){
	// filtre les combos dont un item n'a pas le CD
	var allCombos = [];
	for(var name:var combo in allComboz){
		var ok = true;
		for(var item in combo){
			if(_ITEM_HAVECD[item] && getCooldown(item)!=0){
				ok=false;
				break;
			}
		}
		if(ok) push(allCombos, combo);
	}
	
	//raz du cache.
	_CACHE_SCORE_SAFECELL = [];
	_CACHE_SCORE_ACTION = [];
	var _OP_LIMIT = OPERATIONS_LIMIT*0.95;
	if(_IS_SUMMONER) _OP_LIMIT-= _OPERATION_BULB*(_LEEKS[_SELF][_nbBulbs]+1);
	var _BESTMOVE=null;
	var selfCell = getCell();
	var selfMP = getMP();
	var selfLife = getLife();
	var lifePercent = selfLife/getTotalLife();
	var cntCombo = count(allCombos);
	
	//var __DEBUG_STRINGINFO = "";
	
	for(var combo in allCombos){
		var canAlterDanger = false;
		for(var item in combo) if(_ITEM_CAN_ALTER_DANGER[item]) {canAlterDanger=true; break;}
		cntCombo--;
		var fromArray = [];
		// find cells where every part of combo can be done.
		if(count(combo)==0){ // special case empty combo for safe play.
			push(fromArray, getCell());
		}else{	
			for(var c:var d in reachableCells){
				if(_OBSTACLES[c]!=null) continue;
				var ok = true, isOnlySelf = true;
				for(var item in combo){
					if(assoc_from_item_actions[c][item]==null){
						if(self_action_array[item]==null){
							ok = false;
							break;
						}
					}else{
						isOnlySelf = false;
					}
				}
				if(ok){
					if(isOnlySelf){ if(c==selfCell) { push(fromArray, c); }
					}else{ push(fromArray, c); }
				}
			}
		}
		// DEBUG
		//for(var item in combo) __DEBUG_STRINGINFO += "-" + _ITEMID_TOSTRING[item];
		//__DEBUG_STRINGINFO += ": " + count(fromArray) + "\n";
		// END DEBUG
		for(var aCell in fromArray){
			var mpMove1 = reachableCells[aCell];
			var mpLeft = selfMP - mpMove1;
			if(mpMove1 != null && mpLeft >= 0){
				var score = 0, tmpScore = 0, best = [], total;
				var stack = [], dead = [];
				// calcul du score de la meilleure combo depuis cette case.
				for(var item in combo){
					// meilleure score pour chaque item
					var actions = @assoc_from_item_actions[aCell][item];
					var aScore = 0, aBest, aStack, aDead;
					if(actions!=null){
						for(var action in actions){
							var tmpstack=stack, tmpdead=dead;
							tmpScore=getScoreOfAction(action, tmpstack, tmpdead);
							if(aBest == null || aScore < tmpScore){
								aScore = tmpScore;
								aBest = action;
								aStack = tmpstack;
								aDead = tmpdead;
							}
						}
					}//si actions est null, alors self_action ne peut pas être null.
					if(self_action_array[item]!=null){
						var tmpstack=stack, tmpdead=dead;
						//creation d'une action self sur cette case.
						var action= [_item:item, _from:aCell, _to:aCell, _targets:[_SELF]];
						tmpScore=getScoreOfAction(action, tmpstack, tmpdead);
						if(aBest == null || aScore < tmpScore){
							aScore = tmpScore;
							aBest = action;
							aStack = tmpstack;
							aDead = tmpdead;
						}
					}
					if(aBest != null && aScore>0){
						aBest[_score] = aScore; // pour le debug
						push(best, aBest);
						stack = aStack;
						dead = aDead;
						score += aScore;
					}else{
						//l'action n'a pas été push car inutile, les TP restant sont libre pour lancer un buff
						//mayeb faire autrement, je laisse le commentaire ici.
					}
				}
				// si je me suis boost les mp, on les prend en compte pour la suite
				if(stack[_SELF][_mp]!=null) mpLeft+=round(stack[_SELF][_mp]);
				// à partir du score de la meilleure combo depuis aCell, recherche de la meilleure case safe.
				
				var bestSafeMove = getBestSafeCellScore(canAlterDanger, aCell, dead, stack, selfLife, lifePercent, gravityArray, mpLeft, selfCell);
				
				var safestCell = bestSafeMove[_sCell];
				var safeScore = bestSafeMove[_score];
				var minDanger = bestSafeMove[_danger];
				var mpUsed = bestSafeMove[_mpused];
				
				var finalScore = score + safeScore; // cumul des actions

				if(_BESTMOVE==null || _BESTMOVE[_score]<finalScore) _BESTMOVE = [
					_score:finalScore,
					_actions:best,
					_sCell:safestCell,
					_danger:minDanger,
					_mpused: mpUsed,
					_stack:stack,//pour le debuging
					_dead:dead//pour le debuging
				];
				if(getOperations()>_OP_LIMIT){
					debugE("Turn"+getTurn()+" breaked ! Combos left: "+ cntCombo +"/"+count(allCombos));
					// DEBUG
					//debug(__DEBUG_STRINGINFO);
					// END DEBUG
					return @_BESTMOVE;
				}
			}
		}
	}
	// DEBUG
	//debug(__DEBUG_STRINGINFO);
	// END DEBUG
	return @_BESTMOVE;
}

function getBestSafeCellScore(@canAlterDanger, @aCell, @dead, @stack, @selfLife, @lifePercent, @gravityArray, @mpLeft, @selfCell){
	startBenchFunction("getBestSafeCellScore");
	var uniqId = canAlterDanger ? getUniqueID_safeCell(aCell, dead, stack) : getUniqueID_safeCell(aCell, dead, "");
	if(_CACHE_SCORE_SAFECELL[uniqId]==null){
		var ignored = [selfCell];
		for(var d in dead) push(ignored, getCell(d));
		if(_CACHE_REACHABLE_DANGER[aCell]==null){
			_CACHE_REACHABLE_DANGER[aCell] = getReachableCells([aCell:0], mpLeft, ignored);
			_CACHE_REACHABLE_SIZE[aCell] = mpLeft;
		}else if(_CACHE_REACHABLE_SIZE[aCell] < mpLeft){
			_CACHE_REACHABLE_DANGER[aCell] = getReachableCells(_CACHE_REACHABLE_DANGER[aCell], mpLeft-_CACHE_REACHABLE_SIZE[aCell], ignored);
			_CACHE_REACHABLE_SIZE[aCell] = mpLeft;
		}
		var reachable = @_CACHE_REACHABLE_DANGER[aCell];
		
		var minDanger = 9999999;
		var bestScore = -9999999;
		var safestCell, finalmpUsed;
		var nearECell = getCell(_NEAREST_ENEMY_LEEK);
		var coefNear = _IS_CAC ? 6 : 2;
		var mpE = getMP(_NEAREST_ENEMY_LEEK), mpSelf = getMP();
		mpE -= stack[_NEAREST_ENEMY_LEEK][_shackleMP];
		for(var sCell:var mpused in reachable){
			if(mpused > mpLeft) break;
			var cellDanger = getCellDanger(sCell, dead, stack);
			var danger = cellDanger[_danger], mpUsed = cellDanger[_mpused];
			var tmpScore = 0;
			if(danger > selfLife*_RATIO_IGNORE_DANGER) tmpScore-= danger*_RATIO_DANGER;
			if(lifePercent<0.6) tmpScore*=2;
			if(danger >= selfLife*0.75) tmpScore-=_SCORE_DEATH;
			tmpScore+= mpUsed*_RATIO_MP_USED;
			for(var cell in _areaCells1[sCell]) if(_LEEKS_CELL[cell]!=null && nearECell!=cell) tmpScore-=150;
			for(var cell in _areaCells2[sCell]) if(_LEEKS_CELL[cell]!=null && nearECell!=cell) tmpScore-=20;
			for(var cell:var dist in gravityArray){
				if(cell==nearECell){
					if(_NEARE_FULLMAP_PATH_DIST!=null){
						var pathDist = _NEARE_FULLMAP_PATH_DIST[sCell];
						if(_IS_CAC && pathDist!=null && pathDist + mpE <= mpSelf) tmpScore += 600; // bonus inrange
						if(pathDist==null) tmpScore -= abs(dist-getCellDistance(cell, sCell))*coefNear;
						else tmpScore -= abs(dist-pathDist)*2;
					}else tmpScore -= abs(dist-getCellDistance(cell, sCell))*2;
				}else tmpScore -= abs(dist-getCellDistance(cell, sCell));
			}
			if(_IS_CAC && count(@_areaCells1[nearECell])==1){
				for(var cell in _areaCells1[nearECell]){
					if(cell==sCell) tmpScore+= 3000;
				}
			}
			if(safestCell==null || tmpScore > bestScore){
				safestCell = sCell;
				minDanger = danger;
				bestScore = tmpScore;
				finalmpUsed = mpUsed;
			}
		}
		_CACHE_SCORE_SAFECELL[uniqId] = @[_sCell:safestCell, _danger:minDanger, _score:bestScore, _mpused:finalmpUsed];
	}
	stopBenchFunction("getBestSafeCellScore");
	return @_CACHE_SCORE_SAFECELL[uniqId];
}

function playBestMove(bestMove){
	debug(bestMove);
	var delayedSummon = [];
	for(var action in bestMove[_actions]){
		var item = action[_item], from = action[_from], to = action[_to];
		moveTowardCell(from);
		if(isSpecialChip(item)){ // GESTION SUMMON
			push(delayedSummon, item);
		}else if(_ITEM_ISWEAP[item]){
			if(getWeapon()!=item) setWeapon(item);
			useWeaponOnCell(to);
		}
		else useChipOnCell(item, to);
		debug(_ITEMID_TOSTRING[item]+": "+action[_score]);
		
		// on compte les utilisations :
		if(!isSummon(getLeek())){
			var reg = getRegister(_ITEMID_TOSTRING[item]);
			if(reg==null)setRegister(_ITEMID_TOSTRING[item],1);
			else setRegister(_ITEMID_TOSTRING[item],number(reg)+1);
		}
	}
	if(bestMove[_sCell]!=null){
		moveTowardCell(bestMove[_sCell]);
	}
	for(var item in delayedSummon){
		if(item == CHIP_RESURRECTION){
			var cell = findSafestCellToRez(_RESU_TARGET, getCell());
			resurrect(_RESU_TARGET, cell);
		}else{
			summon(item, getCellToUseChip(item, _SELF), iaBulb);
		}
	}
	if(getTP()>=15 && getCooldown(CHIP_RESURRECTION)==0 && _RESU_TARGET!=null && !isSummon(_RESU_TARGET)){
		var cell = findSafestCellToRez(_RESU_TARGET, getCell());
		resurrect(_RESU_TARGET, cell);
	}
	var _MAINWEAPON = getMainWeapon();
	if(_SHOULD_KEEP_MAINWEAP_INHAND && getWeapon()!= _MAINWEAPON) setWeapon(_MAINWEAPON);
	else if(_MAINWEAPON != null && getWeapon()==null) setWeapon(_MAINWEAPON);
}

/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////
//====================================== BULB =====================================//
/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////

function findBestMoveBulb(@allCombos, @maxOp){
	// raz du cache
	_CACHE_SCORE_ACTION = [];
	var stopingOp = getOperations()+maxOp;
	var _BESTMOVE=null;
	var self = getLeek();
	var selfCell = getCell();
	var selfMP = getMP();
	var selfLife = getLife();
	var cntCombo = count(allCombos);
	for(var combo in allCombos){
		cntCombo--;
		var fromArray = [];
		// find cells where every part of combo can be done.
		for(var c:var d in reachableCells){
			if(_OBSTACLES[c]!=null) continue;
			var ok = true, isOnlySelf = true;
			for(var item in combo){
				if(assoc_from_item_actions[c][item]==null){
					if(self_action_array[item]==null){
						ok = false;
						break;
					}
				}else{
					isOnlySelf = false;
				}
			}
			if(ok){
				if(isOnlySelf){ if(c==selfCell) { push(fromArray, c); }
				}else{ push(fromArray, c); }
			}
		}
		for(var aCell in fromArray){
			var mpMove1 = reachableCells[aCell];
			var mpLeft = selfMP - mpMove1;
			if(mpMove1 != null && mpLeft >= 0){
				var score = 0, tmpScore = 0, best = [], total;
				var stack = [], dead = [];
				// calcul du score de la meilleure combo depuis cette case.
				for(var item in combo){
					// meilleure score pour chaque item
					var actions = @assoc_from_item_actions[aCell][item];
					var aScore = 0, aBest, aStack, aDead;
					if(actions!=null){
						for(var action in actions){
							var tmpstack=stack, tmpdead=dead;
							tmpScore=getScoreOfAction(action, tmpstack, tmpdead);
							if(aBest == null || aScore < tmpScore){
								aScore = tmpScore;
								aBest = action;
								aStack = tmpstack;
								aDead = tmpdead;
							}
						}
					}//si actions est null, alors self_action ne peut pas être null.
					if(self_action_array[item]!=null){
						var tmpstack=stack, tmpdead=dead;
						//creation d'une action self sur cette case.
						var action= [_item:item, _from:aCell, _to:aCell, _targets:[_SELF]];
						tmpScore=getScoreOfAction(action, tmpstack, tmpdead);
						if(aBest == null || aScore < tmpScore){
							aScore = tmpScore;
							aBest = action;
							aStack = tmpstack;
							aDead = tmpdead;
						}
					}
					if(aBest != null && aScore>0){
						aBest[_score] = aScore; // pour le debug
						push(best, aBest);
						stack = aStack;
						dead = aDead;
						score += aScore;
					}else{
						// useless...
					}
				}
				
				if(_BESTMOVE==null || _BESTMOVE[_score]<score) _BESTMOVE = [
					_score:score,
					_actions:best,
					_stack:stack,//pour le debuging
					_dead:dead//pour le debuging
				];
				if(getOperations()>stopingOp){
					debugE("Turn"+getTurn()+" breaked bulb ! Combos left: "+ cntCombo +"/"+count(allCombos));
					return @_BESTMOVE;
				}
			}
		}
	}
	return @_BESTMOVE;
}

// environ 26k pour 7pm
function getSafestCell(@dead, @gravityArray, @ratio_ignore){
	var minDanger = 9999999;
	var bestScore = -9999999;
	var selfLife = getLife();
	var reachable = getReachableCells([getCell():0], getMP(), []);
	var safestCell;
	for(var sCell:var mpused in reachable){
		var danger = getCellDanger(sCell, dead, [])[_danger];
		if(count(_ALIVE_ALLIES_BULBS)>5) danger = 0;
		var tmpScore = 0;
		if(danger > selfLife*ratio_ignore) tmpScore-= danger*_RATIO_DANGER;
		if(danger >= selfLife) tmpScore-=_SCORE_DEATH;
		for(var cell in _areaCells1[sCell]) if(_LEEKS_CELL[cell]!=null) tmpScore-=500;
		for(var cell in _areaCells2[sCell]) if(_LEEKS_CELL[cell]!=null) tmpScore-=300;
		for(var cell in _areaCells3[sCell]) if(_LEEKS_CELL[cell]!=null) tmpScore-=100;
		for(var cell:var dist in gravityArray){
			tmpScore -= abs(dist-getCellDistance(cell, sCell));
		}
		if(safestCell==null || tmpScore > bestScore){
			safestCell = sCell;
			minDanger = danger;
			bestScore = tmpScore;
		}
	}
	return @safestCell;//@[_sCell:safestCell, _danger:minDanger, _score:bestScore];
}

function iaBulb(){
	var limitOp = _OPERATION_BULB*0.3;
	refreshLeeksCellsAndAliveStatus();
	refreshLeeksEffectsAndStates();
	if(getTurn()==getBirthTurn()) updateCoef(getLeek());
	var ratio_ignore = 0.2+_RATIO_IGNORE_DANGER;// ratio de pv que j'ignore pour m'avancer sans mourir
	if(count(_ALIVE_ALLIES_BULBS)>4) ratio_ignore+=0.2;
	if(ratio_ignore>1) ratio_ignore = 0.95;
	
	var gravityArray = [getCell(getNearestEnemy()):4, getCell(getSummoner()):4];
	if(getEntityType(getLeek())==ENTITY_HEALER_BULB){
		ratio_ignore=0;
		gravityArray = [];
		for(var al in _ALIVE_ALLIES_LEEKS) gravityArray[getCell(al)] = 2;
		gravityArray[getCell(getNearestEnemy())] = 25;
	}
	var combos = getComboSet(getLeek());
	var finalCombos = []; // filter cooldown
	for(var combo in combos){
		var ok = true;
		for(var item in combo){
			if(_ITEM_HAVECD[item] && getCooldown(item)!=0){
				ok=false;
				break;
			}
		}
		if(ok) push(finalCombos, combo);
	}
	reachableCells = getReachableCells([getCell():0], getMP(), []);
	startOp();
	setMapActions();
	stopOpkW("BULB mapAction");
	startOp();
	var bestMove = findBestMoveBulb(finalCombos, limitOp);
	stopOpkW("BULB findBest");
	debugW("BEST: "+bestMove);
	if(bestMove!=null) playBestMove(bestMove);
	startOp();
	var dead = bestMove==null ? [] : bestMove[_dead]; 
	var selectedCell = getSafestCell(dead, gravityArray, ratio_ignore);
	moveTowardCell(selectedCell);

	stopOpkW("BULB safeCell");
	debugW('TOTALOP: '+(getOperations()/1000)+'k');
	if(getTP()) say("Bonjour, moi c'est Fab.");
}

