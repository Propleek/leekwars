include('auto');
// INSTRUCTION: lancer un combat de test avec ce leek pour récupérer la liste des combos disponibles en dur dans le registre, en clé le nb de TP, en value les set de combos selon l'arme.
// si pas d'arme en main, prendre la clé "EMPTY" sous forme de string.
// ATTENTION : problème dans le registre, vers 16/17TP, on dépasse les 5000 char, ça rentre pas dans le registre...
// TODO trouver une solution...

global combossssss, knownCombos, combo_mincost, EMPTY=-1;
var inHands = getWeapons();
var maxTP = getTP();
global _STUFF = getWeapons()+getChips();
global _COMBOS_TP = 0;

var itemToRemoveOrdered = [CHIP_ARMORING, CHIP_ANTIDOTE, CHIP_PROTEIN, CHIP_FERTILIZER, CHIP_WINGED_BOOTS, CHIP_STEROID, CHIP_METALLIC_BULB, CHIP_HEALER_BULB, CHIP_SOPORIFIC, CHIP_BALL_AND_CHAIN, CHIP_VACCINE, CHIP_SHIELD, CHIP_RAMPART, CHIP_LIBERATION];

startOp();
while(_COMBOS_TP<=maxTP +4){
	var strrr = getJsonEncodedCombos(inHands);
	if(length(strrr)<=5000){
		var val = setRegister(_COMBOS_TP, strrr);
		if(val) debug("" + _COMBOS_TP + ": " + val + '('+length(strrr)+')');
		else debugE("" + _COMBOS_TP + ": " + val + '('+length(strrr)+')');
		_COMBOS_TP++;
		if(getOperations()>= OPERATIONS_LIMIT*0.90) break;
	}else{
		//remove 1 item from stuff and try again.
		var removed = false;
		for(var item in itemToRemoveOrdered){
			var found = search(_STUFF, item);
			if(found!=null){
				debugW("removing "+_ITEMID_TOSTRING[item]);
				remove(_STUFF,found);
				removed=true;
				break;
			}
		}
		if(removed==false){
			debugE("CANNOT DO MORE TO REDUCE SIZE, EXITING AT "+_COMBOS_TP+"tp.");
			break;
		}
	}
};

stopOpk("Génération des combos");
//outPutComboVar(result);

// retourne une string contenant tous les combos possible pour un montant de TP donnée.
function getJsonEncodedCombos(inHands){
	var result = [];
	for(var w in inHands){
		result[w]= tools2Combo(_STUFF, _COMBOS_TP, w);
	}
	result["EMPTY"] = tools2Combo(_STUFF, _COMBOS_TP, null);
	var final = [];//sort
	for(var startItem:var combosSet in result){
		var combozzz = [];
		for(var combo in combosSet){
			var cmb/*hahaha..*/= arraySort(combo, function(a, b){
				var itemPrioA = _ITEM_PRIORITY[a];
				var itemPrioB = _ITEM_PRIORITY[b];
				if(a==startItem) itemPrioA--;
				if(b==startItem) itemPrioB--;
				if(itemPrioA > itemPrioB) return 1;
				else if(itemPrioA < itemPrioB) return -1;
				return 0;
			});
			push(combozzz, cmb);
		}
		final[startItem] = combozzz;
	}
	var strrr= jsonEncode(final);
	return strrr;
}

// non utilisé pour le moment
function outPutComboVar(comboZ){
	//generation de la string
	var finalString = "\nvar combos = [\n";
	var virg = "";
	for(var startItem:var combobo in comboZ){
		var itemName = startItem==EMPTY ? "'EMPTY'" : _ITEMID_TOSTRING[startItem];
		finalString+= virg + itemName +": [\n";
		var virgule= "";
		for(var combo in combobo){

		// FIXME ça a pas l'air de marcher...
			//sort combo to place some stuff before (like liberation first)
			var cmb/*hahaha..*/= arraySort(combo, function(a, b){
				if(_ITEM_PRIORITY[a] > _ITEM_PRIORITY[b]) return 1;
				else if(_ITEM_PRIORITY[a] < _ITEM_PRIORITY[b]) return -1;
				return 0;
			});


			// TODO mettre en clé le produit de nb premier pour check le cd comme ça dans l'ia
			// une fois qu'on gèrera les combos comme ça.
			finalString+= "\t" + virgule + "[";
			var virgule2= "";
			for(var item in cmb){
				finalString+= virgule2 + _ITEMID_TOSTRING[item];
				if(virgule2=="") virgule2= ", ";
			}
			finalString+= "]\n";
			if(virgule=="") virgule = ",";
		}
		finalString+="]";
		if(virg=="") virg = ",";
	}
	finalString+="];";
	//output
	debug(finalString);
}

function tools2Combo(@tools,@tp,@activeWeapon){
	combossssss = [];
	push(combossssss, []); // fix temporaire : ajout d'une combo vide au début !
	knownCombos = [];
	combo_mincost=50;
	for(var t in tools){
		if(_ITEM_COST[t]<combo_mincost) combo_mincost = _ITEM_COST[t];
	}
	addMoreItem([], tools, tp, activeWeapon);
	
	return combossssss;
}
function addMoreItem(@combo, @tools, @tpleft, @activeWeapon){
	// je n'ai plus assez de TP pour faire la moindre action
	// ou je n'ai plus d'item à ajouter
	if(isEmpty(tools) || combo_mincost>tpleft){
		if(count(combo)>0){ // si la combo n'est pas vide, alors c'est une combo.
			sort(combo); // je la rend unique peu importe l'ordre
			var id = string(combo);
			// j'aurais directement fait combos[id]=combo mais faut passer les tests :P
			if(knownCombos[id]==null){
				knownCombos[id]=true;
				push(combossssss, combo);
			}
		}
	}else{
		var toolsSet = tools, switch, cost;
		// copie tools>toolsSet pour ne pas casser la boucle en retirant des trucs.
		for(var item in tools){
			switch = _ITEM_ISWEAP[item] && item!=activeWeapon ? 1 : 0;
			cost = _ITEM_COST[item]+switch;
			if(tpleft>=cost){ // je peux l'utiliser ?
				// copie pour ne pas impacter les autres branches.
				var currentCombo = combo, 
				currentWeapon = activeWeapon, 
				currentTp = tpleft - cost,//retrait de TP
				currentTools = toolsSet;// copie nécessaire pour ne remove la puce avec CD que dans les sous-branches. à voir pour limiter les copies
				if(switch){
					removeElement(currentTools, currentWeapon); // on ne reswitch pas vers une arme déjà utiliser, gachi de TP, ça fait des combos incomplêtes..
					currentWeapon = item; // switch d'arme
				}
				else if(_ITEM_HAVECD[item]) removeElement(currentTools, item); // puce en CD
				push(currentCombo, item); // ajout de l'item dans la combo
				addMoreItem(currentCombo, currentTools, currentTp, currentWeapon);
			}else{ // on ne pourra plus utiliser cet item.
				removeElement(toolsSet, item);
				if(count(toolsSet)==0) addMoreItem(combo, toolsSet, tpleft, activeWeapon);
			}
		}
	}
}
