include('auto');

function playBestMove(bestMove){
	debug("danger: "+ bestMove[_danger]);
	debug("SafeScor: "+ bestMove[_sScore]);
	debug("mpused: "+ bestMove[_mpused]);
	debug("tpleft: "+ bestMove[_tpleft]);
	debug("kill: "+ bestMove[_dead]);
	debug("totalscore: "+ bestMove[_score]);
	/*
	
	_scores:scores,
								*/
	
	var delayedSummon = [], i=0;
	for(var actionBin in bestMove[_actions]){
		var action = getActionFromBin(actionBin);
		var item = action[_item], from = action[_from], to = action[_to];
		debug("Using " + getItemName(item) + " | " + bestMove[_scores][i++]);
		if(from == _action_SELFCELL){
			from = getCell();
			to = getCell();
		}
		moveTowardCell(from);
		if(isSpecialChip(item)){ // GESTION SUMMON
			push(delayedSummon, item);
		}else if(_ITEM_ISWEAP[item]){
			if(getWeapon()!=item) setWeapon(item);
			if(count(getWeaponTargets(to))>0) useWeaponOnCell(to);
			else debug("No more targets :(");// ptete amélio ça pour pas switch weap
		}
		else if(count(getChipTargets(item, to))>0) useChipOnCell(item, to);
		else debug("No more targets :(");
		
		// on compte les utilisations :
		if(!isSummon(getLeek())){
			countUsage(item);
		}
	}
	if(bestMove[_sCell]!=null){
		moveTowardCell(bestMove[_sCell]);
	}
	for(var item in delayedSummon){
		if(item == CHIP_RESURRECTION){
			var cell = findSafestCellToRez(_RESU_TARGET, getCell());
			resurrect(_RESU_TARGET, cell);
		}else{
			summon(item, getCellToUseChip(item, _SELF), ia_bulb_main);
		}
	}
	// appel à la fonction failSafe défini dans le main, qui utilise les items dispos dans la limite des tps restant dispo
	failSafe();
	// ça permet de summon un bulbe si j'ai rien fait dans mon tour par manque d'opé au tour 1 d'un BR par exemple
	var _MAINWEAPON = getMainWeapon();
	if(_SHOULD_KEEP_MAINWEAP_INHAND && getWeapon()!= _MAINWEAPON) setWeapon(_MAINWEAPON);
	else if(_MAINWEAPON != null && getWeapon()==null) setWeapon(_MAINWEAPON);
}
