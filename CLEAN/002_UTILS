include('auto');
///////////////////////////////////////////
// Fichier de fonction internes
///////////////////////////////////////////

// ========================
// Fonctions pour l'init exclusivement
// ========================

// remplacement de substring qui est bugged
function mySubString(@str, @start, @len){
	var final = "", i = start;
	while(charAt(str, i)!=null && i < start+len){
		final+=charAt(str, i);
		i++;
	}
	return final;
}

// return un id unique pour une weap/chip & un array d'idleek peu importe l'ordre.
// ainsi que la case cible pour les armes à aoe (mettre null sinon pour les lazer !)
function getUniqueID(@array, @w, @to){
	sort(array);
	return @(""+w+array+to);
}

function getUniqueID_safeCell(@cell, @ids){
	sort(ids);
	return @(""+cell+ids);
}

// return reachable cell as an array of [cell:dist]
// cells must be in form : [cell:dist]
// TODO probablement des optis à faire pour les ignoreCells
function getReachableCells(@cells, mp, @ignoreCells){
	var stack = cells;
	var tmp = cells;
	var next = [];
	while(mp--){
		for(var currentWorkingCell : var dist in tmp){
			for(var c in @_areaCells1[currentWorkingCell]){
				if(stack[c] == null && (isEmptyCell(c) || inArray(ignoreCells, c))){
					stack[c] = dist+1;
					next[c] = dist+1;
				}
			}
		}
		tmp = @next;
		next = [];
	}
	return @stack;
}

// return an array of cell according to AREA_CIRCLE_X, ordered from closest to farest.
function prepareCellArea(@c, @obstacle){
    if(_OBSTACLES[c]!=null) return null; // c'est un obstacle, pas besoin de préparer
    var x = getCellX(c), y = getCellY(c), result = [];
    // AREA_CIRCLE_1
    var cell = getCellFromXY(x, y-1);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
    cell = getCellFromXY(x, y+1);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
    cell = getCellFromXY(x-1, y);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
    cell = getCellFromXY(x+1, y);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
	
    return @result;
}

function prepareCellArea2(@c, @obstacle){
    if(_OBSTACLES[c]!=null) return null; // c'est un obstacle, pas besoin de préparer
    var x = getCellX(c), y = getCellY(c), result = [];
    // AREA_CIRCLE_1
    var cell = getCellFromXY(x, y-2);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
    cell = getCellFromXY(x, y+2);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
    cell = getCellFromXY(x-2, y);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
    cell = getCellFromXY(x+2, y);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
	
	cell = getCellFromXY(x+1, y+1);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
    cell = getCellFromXY(x-1, y+1);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
    cell = getCellFromXY(x+1, y-1);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
	cell = getCellFromXY(x-1, y-1);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
	
    return @result;
}

function prepareCellArea3(@c, @obstacle){
    if(_OBSTACLES[c]!=null) return null; // c'est un obstacle, pas besoin de préparer
    var x = getCellX(c), y = getCellY(c), result = [];
    // AREA_CIRCLE_1
    var cell = getCellFromXY(x, y-3);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
    cell = getCellFromXY(x, y+3);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
    cell = getCellFromXY(x-3, y);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
    cell = getCellFromXY(x+3, y);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
	
	cell = getCellFromXY(x+2, y+1);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
    cell = getCellFromXY(x+2, y-1);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
    cell = getCellFromXY(x+1, y+2);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
	cell = getCellFromXY(x+1, y-2);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
	cell = getCellFromXY(x-1, y+2);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
    cell = getCellFromXY(x-1, y-2);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
    cell = getCellFromXY(x-2, y+1);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
	cell = getCellFromXY(x-2, y-1);
    if(cell!=null && (_OBSTACLES[cell]==null || obstacle)) push(result, cell);
	
    return @result;
}

// retourne le type de l'entity
function getEntityType(@entity){
	if(!isSummon(entity)) return @ENTITY_LEEK_;
	if(getLevel()<57) return @ENTITY_PUNY_BULB;
	var chips = getChips(entity);
	if(inArray(chips, CHIP_VACCINE)) return @ENTITY_HEALER_BULB;
	if(inArray(chips, CHIP_ARMOR)) return @ENTITY_METALLIC_BULB;
	if(inArray(chips, CHIP_ROCKFALL)) return @ENTITY_ROCKY_BULB;
	if(inArray(chips, CHIP_ICEBERG)) return @ENTITY_ICED_BULB;
	if(inArray(chips, CHIP_METEORITE)) return @ENTITY_FIRE_BULB;
	if(inArray(chips, CHIP_LIGHTNING)) return @ENTITY_LIGHTNING_BULB;
	return @ENTITY_PUNY_BULB; 
}

function refreshLeeksCellsAndAliveStatus(){
	_SELF = getLeek();
	// refresh leek cells & alive allies/enemies
	_ALIVE_ALLIES = getAliveAllies();
	_ALIVE_ENEMIES = getAliveEnemies();
	_ALIVE_ALLIES_LEEKS = [];
	_ALIVE_ALLIES_BULBS = [];
	_ALIVE_ENEMIES_LEEKS = [];
	_ALIVE_ENEMIES_BULBS = [];
	_ALIVE_ENEMIES_DANGER = [];
	_COUNT_PUNY = 0;
	_COUNT_ROCKY = 0;
	_COUNT_ICED = 0;
	_COUNT_HEALER = 0;
	_COUNT_METAL = 0;
	_COUNT_FIRE = 0;
	_COUNT_LIGHTNING = 0;
	
	_CACHE_CELLS_NO_TELEPORT=null;

	_LEEKS_CELL=[];
	for(var leek in _ALIVE_ALLIES+_ALIVE_ENEMIES){
		if(_SELF!=leek) _LEEKS_CELL[getCell(leek)] = leek;
		if(isAlly(leek)){
			if(isSummon(leek)){
				push(_ALIVE_ALLIES_BULBS, leek);
				var eType = getEntityType(leek);
				if(eType==ENTITY_PUNY_BULB) _COUNT_PUNY++;
				else if(eType==ENTITY_ROCKY_BULB) _COUNT_ROCKY++;
				else if(eType==ENTITY_ICED_BULB) _COUNT_ICED++;
				else if(eType==ENTITY_HEALER_BULB) _COUNT_HEALER++;
				else if(eType==ENTITY_METALLIC_BULB) _COUNT_METAL++;
				else if(eType==ENTITY_FIRE_BULB) _COUNT_FIRE++;
				else if(eType==ENTITY_LIGHTNING_BULB) _COUNT_LIGHTNING++;
			} else push(_ALIVE_ALLIES_LEEKS, leek);
		}else{//isEnemy
			if(isSummon(leek)) push(_ALIVE_ENEMIES_BULBS, leek); 
			else push(_ALIVE_ENEMIES_LEEKS, leek);
			
			if(getStrength(leek) >= 100 || getMagic(leek) >= 100){
				push(_ALIVE_ENEMIES_DANGER, leek);
			}
		}
	}

	_SCN_STR_100 = false;
	_SCN_STR_200 = false;
	_SCN_STR_300 = false;
	for(var e in _ALIVE_ENEMIES){
		if(getStrength(e)>=100 || getScience(e)>=100) _SCN_STR_100 = true;
		if(getStrength(e)>=200 || getScience(e)>=200) _SCN_STR_200 = true;
		if(getStrength(e)>=300 || getScience(e)>=300) _SCN_STR_300 = true;
	}
}

function refreshLeeksEffectsAndStates(){
	// init de l'état des leeks
	_LEEKS=[];
	var lvl = getLevel(), isLvl10 = lvl>=10, isLvl38 = lvl>=38, isLvl61 = lvl>=61;
	for(var leek in _ALIVE_ALLIES+_ALIVE_ENEMIES){
		var effects = [], bulbs = [], psnDmgTurn = 0, psnDmgTotal = 0, scoreLibe = 0;
		// gestion getEffects
		if(isLvl61){
			for(var e in getEffects(leek)){
				setEffectsArray(effects, scoreLibe, psnDmgTurn, psnDmgTotal, e);
			}
		}else{
			for(var castor in _ALIVE_ALLIES+_ALIVE_ENEMIES){
				for(var e in getLaunchedEffects(castor)){
					if(e[6]==leek){
						setEffectsArray(effects, scoreLibe, psnDmgTurn, psnDmgTotal, e);
					}
				}
			}
		}
		if(!isSummon(leek)){
			var bulbz;
			if(isAlly(leek)) bulbz = _ALIVE_ALLIES_BULBS;
			else bulbz = _ALIVE_ENEMIES_BULBS;
			for(var b in bulbz){
				if(getSummoner(b)==leek) push(bulbs, b);
			}
		}
		var leekInfo = [
			"totallife": getTotalLife(leek)
			,"life": getLife(leek)
			,"psnlife": getLife(leek)-psnDmgTurn
			,"psnTurn": psnDmgTurn
			,"psnTotal": psnDmgTotal
			,"effects": @effects
			,"str": getStrength(leek)
			,"mgc": getMagic(leek)
			,"wsd": getWisdom(leek)
			,"rst": getResistance(leek)
			,"agi": getAgility(leek)
			,"snc": getScience(leek)
			,"tp": isLvl10 ? getTP(leek) : 10
			,"mp": isLvl10 ? getMP(leek) : 3
			,"relShield": isLvl38 ? getRelativeShield(leek) : getRelativeByLaunchedEffects(leek)
			,"absShield": isLvl38 ? getAbsoluteShield(leek) : getAbsoluteByLaunchedEffects(leek)
			,"dmgReturn": getDamageReturn(leek)
			,'scoreLibe': scoreLibe
			,'nbBulbs': count(bulbs)//todo check si ça vaut le coup de garder cette info..
			,'bulbs': @bulbs
		];
		_LEEKS[leek] = @leekInfo;
	}
}

function setEffectsArray(@effects, @scoreLibe, @psnDmgTurn, @psnDmgTotal, @e){
	// [type, value, caster_id, turns, critical, item_id, target_id]
	var type = e[0],
	item = e[5],
	value = e[1],
	duration = e[3];
	
	effects[item] += value*duration;
	///// ICI on précalcule le score de libération pour chaque leek.
	// effect négatif, scoreLibe -=
	if(type==EFFECT_POISON){
		psnDmgTurn += value;
		psnDmgTotal += value*duration;
		scoreLibe -= value*duration;
	}else if(type == EFFECT_SHACKLE_STRENGTH){
		scoreLibe -= value*duration;
	}else if(type == EFFECT_SHACKLE_MAGIC){
		scoreLibe -= value*duration;
	}else if(type == EFFECT_SHACKLE_MP){
		scoreLibe -= value*_SCORE_MP*duration;
	}else if(type == EFFECT_SHACKLE_TP){
		scoreLibe -= value*_SCORE_TP*duration;
	// A partir d'ici, effet positif, scoreLibe +=
	}else if(type==EFFECT_HEAL){
		psnDmgTurn -= value;
		psnDmgTotal -= value*duration;
		scoreLibe += value*duration;
	}else if(type == EFFECT_DAMAGE_RETURN){
		scoreLibe += value*duration;
	}else if(type == EFFECT_ABSOLUTE_SHIELD){
		scoreLibe += value*duration;
	}else if(type == EFFECT_RELATIVE_SHIELD){
		scoreLibe += value*_SCORE_REL_SHIELD*duration;
	}else if(type == EFFECT_BUFF_STRENGTH){
		scoreLibe += value*duration;	
	}else if(type == EFFECT_BUFF_AGILITY){
		scoreLibe += value*duration;
	}else if(type == EFFECT_BUFF_MP){
		scoreLibe += value*_SCORE_MP*duration;
	}else if(type == EFFECT_BUFF_TP){
		scoreLibe += value*_SCORE_TP*duration;
	}else if(type == EFFECT_BUFF_WISDOM){
		scoreLibe += value*duration;
	}else if(type == EFFECT_BUFF_RESISTANCE){
		scoreLibe += value*duration;
	}else{
		debugE("Unknown effect type: " + type);
	}
}

function getRelativeByLaunchedEffects(@leek){
	var launchedEffects = getLaunchedEffects(leek);
	var rel = 0;
	for(var effect in launchedEffects){
		if(effect[0] == EFFECT_RELATIVE_SHIELD && effect[6] == leek) rel += effect[1];
	}
	return @rel;
}

function getAbsoluteByLaunchedEffects(@leek){
	var launchedEffects = getLaunchedEffects(leek);
	var abs = 0;
	for(var effect in launchedEffects){
		if(effect[0] == EFFECT_ABSOLUTE_SHIELD && effect[6] == leek) abs += effect[1];
	}
	return @abs;
}

//////////////////////////
// REGISTRE
//////////////////////////

function getFullRegister(key){
	var cnt = 0;
	var reg;
	var strCombos = "";
	do{
		reg = getRegister(key+"-"+cnt);
		if(reg!=null) strCombos+=reg;
		cnt++;
	}while(reg != null);

	var combos = jsonDecode(strCombos);
	return @combos;
}

function setFullRegister(@key, @value){
	var blocksize = 4999;
	var len = length(value);
	var cnt = 0;
	var start=0;
	while(start<len){
		var cle = key+"-"+cnt;
		var size=len-start;
		if(size > blocksize) size = blocksize;
		var substr = mySubString(value, start, size);
		debug("len:"+length(substr)+" start:"+start+" size:"+size);
		var val = setRegister(cle, substr);
		if(val) debug(key+" OK"); 
		else debugE(key+" "+length(substr));
		cnt++;
		start = cnt*blocksize;
	}
}

//////////////////////////
// DEBUG
//////////////////////////
function debugColor(message, color){
	if(__DEBUG_ON) debugW("|||{"+color+"}"+message);
}
// mesure d'opération simple
function startOp(){
	__debug_operation = getOperations();
}
function stopOp(title){
	if(__DEBUG_ON) debug(title + ": " + (getOperations()-__debug_operation-7));	
}
function stopOpk(title){
	if(__DEBUG_ON) debug(title + ": " + round((getOperations()-__debug_operation)/1000) + "k");
}
function stopOpkW(title){
	if(__DEBUG_ON) debugW(title + ": " + round((getOperations()-__debug_operation)/1000) + "k");
}
// mesure de consommation d'opération moyenne d'une fonction
function resetBench(){
	__count_func = [];
	__cumul_func = [];
	__laststart_func = [];
}
function startBenchFunction(name){
	if(__count_func[name]==null) __count_func[name]=0;
	if(__cumul_func[name]==null) __cumul_func[name]=0;
	__laststart_func[name] = getOperations();
}
function stopBenchFunction(name){
	__count_func[name]++;
	__cumul_func[name]+= getOperations()-__laststart_func[name];
}
function displayBench(){
	for(var name:var nbCall in __count_func){
		debugColor("Turn"+ getTurn() + " "+ name + ": " + nbCall + " call. Moy= " + round(__cumul_func[name]/nbCall) + " Total= " + round((__cumul_func[name])/1000) + "k", "blue");
	}
}

function colorMap(){
	var max=getLife();
	var white = getColor(255, 255, 255);
	for(var cell: var dmg in map_danger){
		if(dmg>=max) mark(cell, white);
		else mark(cell, getColor(dmg/max*255, 255-(dmg/max*255), 0));
	}
}
